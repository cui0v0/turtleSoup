<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ·é¾Ÿæ±¤ Online</title>
    <script src="./tailwindcss_browser@4.js"></script>
    <script src="./vue.global.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .chat-bubble { max-width: 80%; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.5s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4 max-w-4xl pb-24 md:pb-4">
        
        <!-- ç™»å½•ç•Œé¢ -->
        <div v-if="!joined" class="flex flex-col items-center justify-center h-screen">
            <h1 class="text-6xl font-bold mb-8 text-emerald-500">ğŸ¢ æµ·é¾Ÿæ±¤</h1>
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
                <label class="block mb-2 text-lg">è¯·è¾“å…¥æ˜µç§°</label>
                <input v-model="nickname" @keyup.enter="joinGame" type="text" class="w-full p-3 rounded bg-gray-700 border border-gray-600 focus:border-emerald-500 focus:outline-none mb-4" placeholder="ä½ çš„åå­—...">
                <button @click="joinGame" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded transition cursor-pointer">è¿›å…¥æˆ¿é—´</button>
            </div>
        </div>

        <!-- æ¸¸æˆä¸»ç•Œé¢ -->
        <div v-else>
            <!-- é¡¶éƒ¨æ  -->
            <header class="flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-lg">
                <div>
                    <h1 class="text-2xl font-bold text-emerald-500">æµ·é¾Ÿæ±¤ Online</h1>
                    <p class="text-sm text-gray-400">å½“å‰èº«ä»½: <span :class="isHost ? 'text-yellow-400 font-bold' : 'text-blue-400'">{{ isHost ? 'ä¸»æŒäºº (Host)' : 'ä¾¦æ¢ (Player)' }}</span></p>
                </div>
                <div class="flex items-center gap-4">
                    <div class="text-right">
                        <p class="text-sm">åœ¨çº¿äººæ•°: {{ players.length }}</p>
                        <p class="text-xs text-gray-500">{{ nickname }}</p>
                    </div>
                    <button v-if="!isHost && !hasHost && !currentPuzzle" @click="claimHost" class="text-xs bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-white font-bold animate-pulse">æˆä¸ºä¸»æŒäºº</button>
                    <button v-if="!isHost && hasHost && !currentPuzzle" @click="requestHost" :disabled="requestHostCooldown" :class="requestHostCooldown ? 'opacity-50 cursor-not-allowed' : ''" class="text-xs bg-emerald-600 hover:bg-emerald-700 px-2 py-1 rounded">ç”³è¯·ä¸»æŒ</button>
                    <button v-if="isHost && !currentPuzzle" @click="resignHost" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white">é€€å‡ºä¸»æŒ</button>
                </div>
            </header>

            <!-- ä¸»æŒäººé€‰æ‹©å¼¹çª— (ä»…å½“æ²¡æœ‰ä¸»æŒäººä¸”è‡ªå·±ä¸æ˜¯ä¸»æŒäººæ—¶æ˜¾ç¤º) -->
            <div v-if="!hasHost && !isHost" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <h2 class="text-3xl font-bold mb-4 text-yellow-400">ğŸ¢ è°æ¥å½“æµ·é¾Ÿï¼Ÿ</h2>
                    <p class="text-gray-300 mb-8">å½“å‰æˆ¿é—´è¿˜æ²¡æœ‰ä¸»æŒäººã€‚<br>ä½ æƒ³æˆä¸ºä¸»æŒäººå‡ºé¢˜å—ï¼Ÿ</p>
                    <div class="flex flex-col gap-4">
                        <button @click="claimHost" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 rounded transition text-lg cursor-pointer">
                            æˆ‘æ¥å½“ä¸»æŒäººï¼
                        </button>
                        <p class="text-sm text-gray-500">æˆ–è€…ç­‰å¾…å…¶ä»–äººæˆä¸ºä¸»æŒäºº...</p>
                    </div>
                </div>
            </div>
            <!-- æ¢å¤æ¸¸æˆå†³å®šå¼¹çª— (ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶) -->
            <div v-if="showRecoveryDecision" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[60]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-lg border border-blue-500 shadow-2xl">
                    <h2 class="text-3xl font-bold mb-4 text-blue-400">ğŸ”„ å‘ç°ä¸Šä¸€åœºæ¸¸æˆè®°å½•</h2>
                    <p class="text-gray-300 mb-6 text-lg">æ£€æµ‹åˆ°æœåŠ¡å™¨é‡å¯å‰æœ‰æœªå®Œæˆçš„æ¸¸æˆå¯¹å±€ï¼Œæ˜¯å¦è¦æ¢å¤ï¼Ÿ</p>
                    <div class="bg-blue-900/30 border border-blue-600 rounded p-4 mb-6">
                        <p class="text-blue-200 text-sm">âœ“ æ¢å¤æ¸¸æˆå°†ä¿ç•™æ‰€æœ‰æ¨ç†å†å²å’Œé¢˜ç›®ä¿¡æ¯</p>
                        <p class="text-blue-200 text-sm mt-2">âœ“ æ‰€æœ‰ç©å®¶å°†æ¢å¤åŸæœ‰çš„æ˜µç§°å’Œè§’è‰²</p>
                    </div>
                    <div class="flex gap-4">
                        <button @click="startNewGame" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 rounded transition cursor-pointer">
                            é‡å¼€æ–°å±€
                        </button>
                        <button @click="recoverGame" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded transition cursor-pointer">
                            æ¢å¤æ¸¸æˆ
                        </button>
                    </div>
                </div>
            </div>

            <!-- ç­‰å¾…æ¢å¤å†³å®šå¼¹çª— (å…¶ä»–ç©å®¶) -->
            <div v-if="showRecoveryWaiting" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[55]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <div class="mb-6">
                        <svg class="animate-spin h-16 w-16 text-yellow-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h2 class="text-2xl font-bold mb-4 text-yellow-400">â³ ç­‰å¾…å†³å®šä¸­...</h2>
                    <p class="text-gray-300 text-lg">å…¶ä»–ç©å®¶æ­£åœ¨å†³å®šæ˜¯å¦æ¢å¤ä¸Šä¸€åœºæ¸¸æˆ</p>
                    <p class="text-gray-500 text-sm mt-4">è¯·ç¨å€™</p>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                
                <!-- å·¦ä¾§/ä¸Šæ–¹ï¼šé¢˜ç›®åŒºåŸŸ -->
                <div class="md:col-span-2 space-y-6">
                    <!-- é€‰é¢˜åŒºåŸŸ (ä»…ä¸»æŒäººä¸”æ— é¢˜ç›®æ—¶æ˜¾ç¤º) -->
                    <div v-if="isHost && !currentPuzzle" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold text-yellow-400">é€‰æ‹©ä¸€ä¸ªæ±¤é¢</h2>
                            <button @click="showCustomModal = true" class="text-sm bg-emerald-600 hover:bg-emerald-700 px-3 py-1 rounded text-white transition cursor-pointer">+ è‡ªå®šä¹‰</button>
                        </div>
                        <div class="space-y-2 max-h-96 overflow-y-auto">
                            <div v-for="p in puzzleList" :key="p.id" @click="previewPuzzleDetails(p)" 
                                class="p-4 bg-gray-700 hover:bg-gray-600 rounded cursor-pointer transition border-l-4 border-transparent hover:border-yellow-400">
                                <h3 class="font-bold">{{ p.title }}</h3>
                                <p class="text-sm text-gray-400 truncate">{{ p.content }}</p>
                            </div>
                        </div>
                    </div>

                    <!-- é¢˜ç›®é¢„è§ˆæ¨¡æ€æ¡† -->
                    <div v-if="showPreviewModal && previewPuzzle" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-2xl border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto">
                            <h3 class="text-2xl font-bold mb-4 text-yellow-400">{{ previewPuzzle.title }}</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-bold text-emerald-400 mb-2">æ±¤é¢ (é¢˜ç›®)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        {{ previewPuzzle.content }}
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-red-400 mb-2">æ±¤åº• (ç­”æ¡ˆ)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        {{ previewPuzzle.answer }}
                                    </div>
                                </div>
                                <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3 text-sm text-yellow-200">
                                    <p>ğŸ’¡ æç¤º: ç©å®¶åªèƒ½çœ‹åˆ°æ±¤é¢ï¼Œä¸ä¼šçœ‹åˆ°æ±¤åº•ã€‚è¯·ç¡®è®¤æ­¤é¢˜ç›®åˆé€‚åå†å¼€å§‹æ¸¸æˆã€‚</p>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showPreviewModal = false; previewPuzzle = null;" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="confirmStartPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                            </div>
                        </div>
                    </div>

                    <!-- è‡ªå®šä¹‰é¢˜ç›®æ¨¡æ€æ¡† -->
                    <div v-if="showCustomModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-lg border border-gray-700 shadow-2xl">
                            <h3 class="text-xl font-bold mb-4 text-emerald-500">è‡ªå®šä¹‰æµ·é¾Ÿæ±¤</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ ‡é¢˜</label>
                                    <input v-model="customForm.title" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="ä¾‹å¦‚ï¼šææ€–çš„ç”µæ¢¯">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤é¢ (é¢˜ç›®)</label>
                                    <textarea v-model="customForm.content" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="æè¿°ç©å®¶çœ‹åˆ°çš„æƒ…æ™¯..."></textarea>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤åº• (ç­”æ¡ˆ)</label>
                                    <textarea v-model="customForm.answer" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="äº‹æƒ…çš„çœŸç›¸æ˜¯..."></textarea>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showCustomModal = false" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="submitCustomPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                            </div>
                        </div>
                    </div>

                    <!-- é¢˜ç›®æ˜¾ç¤ºåŒºåŸŸ -->
                    <div v-if="currentPuzzle" class="bg-gray-800 p-6 -mx-4 md:mx-0 rounded-none md:rounded-lg shadow-lg border-t-4 border-emerald-500 sticky top-0 z-30 md:static transition-all">
                        <div class="flex justify-between items-start mb-2">
                            <h2 class="text-2xl font-bold truncate pr-2">{{ currentPuzzle.title }}</h2>
                            <div v-if="isHost" class="flex gap-2 shrink-0">
                                <button @click="revealAnswer" v-if="!gameOver" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white cursor-pointer">æ­æ™“</button>
                                <button @click="returnToLobby" class="text-xs bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded text-white cursor-pointer">è¿”å›</button>
                            </div>
                        </div>

                        <!-- ç§»åŠ¨ç«¯è§†å›¾ (å¯æŠ˜å ) -->
                        <div class="md:hidden cursor-pointer group" @click="isPuzzleExpanded = !isPuzzleExpanded">
                            <p :class="{'line-clamp-1': !isPuzzleExpanded}" class="text-lg leading-relaxed text-gray-200 mb-1 transition-all">{{ currentPuzzle.content }}</p>
                            
                            <div v-if="(isHost || gameOver) && isPuzzleExpanded" class="mt-1 p-3 bg-gray-900 rounded border border-gray-700 text-base">
                                <h3 class="font-bold text-red-400 mb-1">æ±¤åº•:</h3>
                                <p class="text-gray-300">{{ currentPuzzle.answer }}</p>
                            </div>

                            <p v-if="!isPuzzleExpanded" class="text-xs text-gray-500 text-center mt-1 group-hover:text-emerald-400">â–¼ ç‚¹å‡»å±•å¼€è¯¦æƒ…</p>
                            <p v-else class="text-xs text-gray-500 text-center mt-2">â–² ç‚¹å‡»æ”¶èµ·</p>
                        </div>

                        <!-- PCç«¯è§†å›¾ (æ€»æ˜¯å®Œæ•´æ˜¾ç¤º) -->
                        <div class="hidden md:block">
                            <p class="text-lg leading-relaxed text-gray-200 mb-4">{{ currentPuzzle.content }}</p>
                            
                            <div v-if="isHost || gameOver" class="mt-6 p-4 bg-gray-900 rounded border border-gray-700">
                                <h3 class="text-sm font-bold text-red-400 mb-1">æ±¤åº• (Answer):</h3>
                                <p class="text-gray-300">{{ currentPuzzle.answer }}</p>
                            </div>
                        </div>
                    </div>

                    <!-- ç­‰å¾…é¢˜ç›® -->
                    <div v-if="!currentPuzzle && !isHost" class="bg-gray-800 p-12 rounded-lg text-center text-gray-500">
                        <p class="text-xl">ç­‰å¾…ä¸»æŒäººå‡ºé¢˜...</p>
                    </div>

                    <!-- æé—®å†å² -->
                    <div v-if="currentPuzzle" class="bg-gray-800 p-4 rounded-lg shadow-lg min-h-[400px] flex flex-col">
                        <h3 class="text-lg font-bold mb-4 border-b border-gray-700 pb-2">æ¨ç†è®°å½•</h3>
                        <div class="flex-1 overflow-y-auto space-y-4 pr-2 custom-scrollbar" ref="historyBox">
                            <div v-for="item in history" :key="item.id" :class="{
                                        'bg-green-700/50': item.answerType === 'yes',
                                        'bg-red-700/50': item.answerType === 'no',
                                        'bg-gray-700/50': item.answerType === 'irrelevant',
                                        'bg-blue-700/50': item.answerType === 'custom',
                                        'bg-yellow-600/50': item.status === 'pending'
                                    }" class="bg-gray-700/50 p-3 rounded">
                                <div class="flex justify-between text-sm text-white/70 mb-1">
                                    <span>{{ item.nickname }}</span>
                                    <span v-if="item.status === 'pending'" class="text-yellow-500">ç­‰å¾…å›ç­”...</span>
                                </div>
                                <p class="font-medium text-white mb-2">Q: {{ item.question }}</p>
                                
                                <!-- å›ç­”åŒºåŸŸ -->
                                <div v-if="item.status === 'answered'" class="flex items-center gap-2 mt-2 pl-4 border-l-2 border-emerald-500">
                                    <span class="text-emerald-400 font-bold">A:</span>
                                    <span :class="{
                                        'text-green-400': item.answerType === 'yes',
                                        'text-red-400': item.answerType === 'no',
                                        'text-gray-400': item.answerType === 'irrelevant',
                                        'text-blue-400': item.answerType === 'custom'
                                    }">{{ item.answer }}</span>
                                </div>

                                <!-- ä¸»æŒäººæ“ä½œåŒº -->
                                <div v-if="isHost && item.status === 'pending'" class="mt-2 flex gap-2 flex-wrap flex-col">
                                    <div class="flex justify-between gap-4">
                                        <button @click="answer(item.id, 'yes')" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-base flex-grow cursor-pointer">æ˜¯</button>
                                        <button @click="answer(item.id, 'no')" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-base flex-grow cursor-pointer">ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'irrelevant')" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-base flex-grow cursor-pointer">ä¸é‡è¦</button>
                                    </div>
                                    <div class="flex justify-between gap-2">
                                        <input v-model="customAnswers[item.id]" placeholder="è‡ªå®šä¹‰å›ç­”" class="bg-gray-900 text-base px-2 py-1 rounded border border-gray-600 w-46 flex-grow-2">
                                        <button @click="answer(item.id, 'custom')" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded text-base flex-grow cursor-pointer">å‘é€</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§/ä¸‹æ–¹ï¼šæé—®è¾“å…¥æ¡† -->
                <div class="md:col-span-1">
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg sticky top-4">
                        <div v-if="!isHost && currentPuzzle" class="hidden md:block mb-6">
                            <h3 class="font-bold mb-2 text-emerald-400 flex justify-between items-center">
                                <span>æé—®</span>
                                <span v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" class="text-xs text-gray-400 font-normal">
                                    å‰©ä½™: 
                                    <span v-if="gameLimits.maxQuestionsPerPlayer">{{ Math.max(0, gameLimits.maxQuestionsPerPlayer - myQuestionCount) }} (ä¸ªäºº)</span>
                                    <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions"> + </span>
                                    <span v-if="gameLimits.maxTotalQuestions">{{ Math.max(0, gameLimits.maxTotalQuestions - publicUsedCount) }} (å…¬å…±)</span>
                                </span>
                            </h3>
                            <textarea v-model="questionText" :disabled="!canAskQuestion" 
                                class="w-full h-32 bg-gray-700 rounded p-3 text-white focus:outline-none focus:ring-2 focus:ring-emerald-500 disabled:opacity-50 disabled:cursor-not-allowed"
                                :placeholder="questionPlaceholder"></textarea>
                            <button @click="sendQuestion" :disabled="!canAskQuestion || !questionText.trim()"
                                class="w-full mt-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold py-2 rounded transition cursor-pointer">
                                å‘é€æé—®
                            </button>
                        </div>
                        
                        <div>
                            <h3 class="font-bold mb-2 text-gray-400 text-base flex justify-between items-center">
                                <span>åœ¨çº¿ç©å®¶</span>
                                <span v-if="gameDuration" class="text-sm text-emerald-400 font-mono">{{ gameDuration }}</span>
                            </h3>
                            <ul class="space-y-1 text-sm">
                                <li v-for="p in players" :key="p.id" class="flex items-center gap-2" :class="{'opacity-50': !p.isOnline}">
                                    <span class="w-2 h-2 rounded-full" :class="[p.isOnline ? (p.isHost ? 'bg-yellow-400' : 'bg-green-400') : 'bg-gray-500']"></span>
                                    <span :class="{'text-yellow-400': p.isHost}">{{ p.nickname }}</span>
                                    <span v-if="!p.isOnline" class="text-xs text-red-400">(ç¦»çº¿)</span>
                                    <span v-if="p.id === myId" class="text-gray-500 text-xs">(æˆ‘)</span>
                                    <button v-if="isHost && !p.isOnline" @click="kickPlayer(p.id)" class="ml-auto text-xs bg-red-900/80 hover:bg-red-700 text-white px-2 py-1 rounded border border-red-700 transition cursor-pointer" title="è¸¢å‡ºè¯¥ç©å®¶">è¸¢å‡º</button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <!-- ç§»åŠ¨ç«¯åº•éƒ¨æé—®æ  -->
        <div v-if="!isHost && currentPuzzle && !gameOver" class="md:hidden fixed bottom-0 left-0 right-0 bg-gray-800 p-3 border-t border-gray-700 z-40 flex flex-col gap-2 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)]">
            <div v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" class="text-xs text-gray-400 text-right px-1">
                å‰©ä½™: 
                <span v-if="gameLimits.maxQuestionsPerPlayer">{{ Math.max(0, gameLimits.maxQuestionsPerPlayer - myQuestionCount) }} (ä¸ªäºº)</span>
                <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions"> + </span>
                <span v-if="gameLimits.maxTotalQuestions">{{ Math.max(0, gameLimits.maxTotalQuestions - publicUsedCount) }} (å…¬å…±)</span>
            </div>
            <div class="flex gap-2 items-end">
                <textarea id="mobile-question-input" v-model="questionText" rows="1" @input="autoResize" :disabled="!canAskQuestion"
                    class="flex-1 bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-emerald-500 resize-none overflow-hidden min-h-[40px] max-h-[120px] text-sm disabled:opacity-50" 
                    :placeholder="questionPlaceholder"></textarea>
                <button @click="sendQuestion" :disabled="!canAskQuestion || !questionText.trim()" 
                    class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold px-4 py-2 rounded transition h-[40px] flex items-center justify-center text-sm whitespace-nowrap cursor-pointer">
                    å‘é€
                </button>
            </div>
        </div>

        <!-- æœåŠ¡å™¨æ–­å¼€è¿æ¥è­¦å‘Š -->
        <div v-if="!serverConnected && !showRecoveryDecision && !showRecoveryWaiting" class="fixed bottom-0 left-0 right-0 bg-red-600 text-white py-3 px-4 shadow-lg z-50 animate-pulse">
            <div class="container mx-auto flex items-center justify-center gap-3">
                <span class="font-bold text-lg">âš ï¸ æœåŠ¡å™¨è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...</span>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, nextTick } = Vue;
        let socket; // å»¶è¿Ÿåˆå§‹åŒ–
        let pendingJoinPayload = null; // åœ¨è¿æ¥å»ºç«‹å‰ç¼“å­˜ join è¯·æ±‚

        createApp({
            setup() {
                const joined = ref(false);
                const nickname = ref('');
                const myId = ref('');
                const isHost = ref(false);
                const players = ref([]);
                const puzzleList = ref([]);
                const currentPuzzle = ref(null);
                const history = ref([]);
                const questionText = ref('');
                const customAnswers = ref({});
                const gameOver = ref(false);
                const historyBox = ref(null);
                
                // è‡ªå®šä¹‰é¢˜ç›®ç›¸å…³
                const showCustomModal = ref(false);
                const customForm = ref({ title: '', content: '', answer: '' });
                const hasHost = ref(false); // æ˜¯å¦å·²æœ‰ä¸»æŒäºº
                const persistRole = (hostFlag) => {
                    localStorage.setItem('turtle_role', hostFlag ? 'host' : 'player');
                };
                
                // é¢˜ç›®é¢„è§ˆç›¸å…³
                const showPreviewModal = ref(false);
                const previewPuzzle = ref(null);
                
                // ç”³è¯·ä¸»æŒå†·å´æ—¶é—´
                const requestHostCooldown = ref(false);
                
                // æœåŠ¡å™¨è¿æ¥çŠ¶æ€
                const serverConnected = ref(true);
                
                // æ¢å¤å†³å®šç›¸å…³
                const showRecoveryDecision = ref(false);
                const showRecoveryWaiting = ref(false);
                
                // æ¸¸æˆé™åˆ¶ç›¸å…³
                const gameLimits = ref({ maxQuestionsPerPlayer: null, maxTotalQuestions: null });
                const settingsForm = ref({ maxQuestionsPerPlayer: '', maxTotalQuestions: '' });
                
                // æ¸¸æˆæ—¶é•¿ç›¸å…³
                const gameStartTime = ref(null);
                const gameDuration = ref('');
                let durationTimer = null;

                const updateDuration = () => {
                    if (!gameStartTime.value) {
                        gameDuration.value = '';
                        return;
                    }
                    const now = Date.now();
                    const diff = Math.floor((now - gameStartTime.value) / 1000);
                    const hours = Math.floor(diff / 3600).toString().padStart(2, '0');
                    const minutes = Math.floor((diff % 3600) / 60).toString().padStart(2, '0');
                    const seconds = (diff % 60).toString().padStart(2, '0');
                    gameDuration.value = `${hours}:${minutes}:${seconds}`;
                };

                const startDurationTimer = () => {
                    if (durationTimer) clearInterval(durationTimer);
                    updateDuration();
                    durationTimer = setInterval(updateDuration, 1000);
                };

                const stopDurationTimer = () => {
                    if (durationTimer) {
                        clearInterval(durationTimer);
                        durationTimer = null;
                    }
                    gameDuration.value = '';
                };
                
                const { computed } = Vue;
                
                const myQuestionCount = computed(() => {
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (!storedUserId) return 0;
                    return history.value.filter(q => q.userId === storedUserId).length;
                });
                
                // è®¡ç®—å…¬å…±æ± å·²ç”¨æ¬¡æ•°
                const publicUsedCount = computed(() => {
                    if (!gameLimits.value.maxQuestionsPerPlayer) return 0;
                    
                    let used = 0;
                    const userCounts = {};
                    
                    history.value.forEach(q => {
                        if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                        if (userCounts[q.userId] >= gameLimits.value.maxQuestionsPerPlayer) {
                            used++;
                        }
                        userCounts[q.userId]++;
                    });
                    
                    return used;
                });
                
                const canAskQuestion = computed(() => {
                    if (!currentPuzzle.value || gameOver.value) return false;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return false;
                    }

                    const limits = gameLimits.value;
                    
                    // æƒ…å†µ1: ä»…æœ‰æ€»é™åˆ¶ (å…¼å®¹æ—§é€»è¾‘)
                    if (!limits.maxQuestionsPerPlayer && limits.maxTotalQuestions) {
                        return history.value.length < limits.maxTotalQuestions;
                    }
                    
                    // æƒ…å†µ2: æœ‰ä¸ªäººé™åˆ¶
                    if (limits.maxQuestionsPerPlayer) {
                        // 2.1 ä¸ªäººé…é¢æœªç”¨å®Œ -> å…è®¸
                        if (myQuestionCount.value < limits.maxQuestionsPerPlayer) {
                            return true;
                        }
                        
                        // 2.2 ä¸ªäººé…é¢å·²ç”¨å®Œ -> æ£€æŸ¥æ˜¯å¦æ‰€æœ‰åœ¨çº¿ç©å®¶éƒ½ç”¨å®Œäº†
                        const onlinePlayers = players.value.filter(p => p.isOnline && !p.isHost);
                        // ç»Ÿè®¡æ¯ä¸ªåœ¨çº¿ç©å®¶çš„å·²ç”¨æ¬¡æ•°
                        const userCounts = {};
                        history.value.forEach(q => {
                            if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                            userCounts[q.userId]++;
                        });
                        
                        const someoneHasQuota = onlinePlayers.some(p => {
                            const used = userCounts[p.userId] || 0;
                            return used < limits.maxQuestionsPerPlayer;
                        });
                        
                        if (someoneHasQuota) {
                            return false; // è¿˜æœ‰äººæ²¡ç”¨å®Œï¼Œå¿…é¡»ç­‰å¾…
                        }
                        
                        // 2.3 å¤§å®¶éƒ½ç”¨å®Œäº† -> æ£€æŸ¥å…¬å…±é…é¢
                        if (limits.maxTotalQuestions !== null) {
                            return publicUsedCount.value < limits.maxTotalQuestions;
                        }
                        
                        return true; // æ— å…¬å…±é™åˆ¶ï¼Œæ— é™é—®
                    }
                    
                    return true;
                });
                
                const questionPlaceholder = computed(() => {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return 'è¯·ç­‰å¾…ä¸»æŒäººå›ç­”æ‚¨æå‡ºçš„ä¸Šä¸€æ¡çŒœæµ‹...';
                    }

                    if (!canAskQuestion.value) {
                        const limits = gameLimits.value;
                        if (limits.maxQuestionsPerPlayer && myQuestionCount.value >= limits.maxQuestionsPerPlayer) {
                            // æ£€æŸ¥æ˜¯å¦æœ‰äººæ²¡ç”¨å®Œ
                            const onlinePlayers = players.value.filter(p => p.isOnline && !p.isHost);
                            const userCounts = {};
                            history.value.forEach(q => {
                                if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                                userCounts[q.userId]++;
                            });
                            const someoneHasQuota = onlinePlayers.some(p => {
                                const used = userCounts[p.userId] || 0;
                                return used < limits.maxQuestionsPerPlayer;
                            });
                            
                            if (someoneHasQuota) return 'è¯·ç­‰å¾…å…¶ä»–ç©å®¶ä½¿ç”¨å®Œä¸ªäººæ¬¡æ•°';
                            if (limits.maxTotalQuestions && publicUsedCount.value >= limits.maxTotalQuestions) return 'å…¨å‘˜å…¬å…±æ¬¡æ•°å·²ç”¨å°½';
                        }
                        return 'æé—®æ¬¡æ•°å·²ç”¨å°½';
                    }
                    return 'è¾“å…¥ä½ çš„é—®é¢˜... (åªèƒ½é—®æ˜¯/å¦çš„é—®é¢˜å“¦)';
                });

                // ç§»åŠ¨ç«¯UIçŠ¶æ€
                const isPuzzleExpanded = ref(false);
                const autoResize = (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = e.target.scrollHeight + 'px';
                };

                // åˆå§‹åŒ–Socketè¿æ¥å’Œç›‘å¬å™¨
                const initSocket = () => {
                    if (socket) return; // é˜²æ­¢é‡å¤è¿æ¥
                    socket = io();

                    socket.on('connect', () => {
                        serverConnected.value = true;
                        const storedUserId = localStorage.getItem('turtle_uid');
                        const sessionId = localStorage.getItem('turtle_session_id');
                        const roleHint = localStorage.getItem('turtle_role');

                        if (pendingJoinPayload) {
                            socket.emit('join', pendingJoinPayload);
                            pendingJoinPayload = null;
                            return;
                        }

                        // å¦‚æœå·²ç»åŠ å…¥è¿‡æ¸¸æˆï¼ˆæ–­çº¿é‡è¿çš„æƒ…å†µï¼‰ï¼Œè‡ªåŠ¨é‡æ–°å‘é€join
                        if (joined.value) {
                            socket.emit('join', { 
                                nickname: nickname.value, 
                                userId: storedUserId,
                                sessionId,
                                roleHint
                            });
                        }
                    });

                    socket.on('init_state', (state) => {
                        // æ£€æŸ¥æœåŠ¡å™¨ä¼šè¯ID
                        const storedSessionId = localStorage.getItem('turtle_session_id');
                        
                        // æ¢å¤æ¨¡å¼ï¼šæœåŠ¡å™¨æœ‰ä¿å­˜çš„æ¸¸æˆçŠ¶æ€
                        if (state.recoveryMode) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æœåŠ¡å™¨é‡å¯åçš„æƒ…å†µ
                            if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                                // æœåŠ¡å™¨é‡å¯äº†ï¼Œä½†æœ‰å¯æ¢å¤çš„æ¸¸æˆ
                                localStorage.setItem('turtle_session_id', state.serverSessionId);
                                
                                // å…ˆæç¤ºæœåŠ¡å™¨é‡å¯
                                alert('æœåŠ¡å™¨å·²é‡å¯');
                                
                                // ç„¶åæ˜¾ç¤ºæ¢å¤å†³å®šå¼¹çª—
                                if (state.waitingForRecoveryDecision) {
                                    if (state.isFirstReconnector) {
                                        showRecoveryDecision.value = true;
                                    } else {
                                        showRecoveryWaiting.value = true;
                                    }
                                }
                                
                                // æ›´æ–°çŠ¶æ€ä½†ä¸åˆ·æ–°é¡µé¢
                                myId.value = state.myId;
                                if (state.userId) {
                                    localStorage.setItem('turtle_uid', state.userId);
                                    localStorage.setItem('turtle_nickname', nickname.value);
                                }
                                
                                players.value = state.players;
                                const me = state.players.find(p => p.id === state.myId);
                                isHost.value = me?.isHost || false;
                                persistRole(isHost.value);
                                hasHost.value = state.players.some(p => p.isHost);
                                
                                currentPuzzle.value = state.currentPuzzle;
                                history.value = state.history;
                                puzzleList.value = state.puzzles;
                                if (state.limits) {
                                    gameLimits.value = state.limits;
                                }
                                if (state.startTime) {
                                    gameStartTime.value = state.startTime;
                                    startDurationTimer();
                                }
                                scrollToBottom();
                                return;
                            }
                            
                            // ä¸æ¸…é™¤èº«ä»½ä¿¡æ¯ï¼Œç›´æ¥æ¢å¤
                            console.log('Recovery mode: restoring previous game state');
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¦‚æœåœ¨ç­‰å¾…æ¢å¤å†³å®š
                            if (state.waitingForRecoveryDecision) {
                                if (state.isFirstReconnector) {
                                    // ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶ï¼Œæ˜¾ç¤ºå†³å®šå¼¹çª—
                                    showRecoveryDecision.value = true;
                                } else {
                                    // å…¶ä»–ç©å®¶ï¼Œæ˜¾ç¤ºç­‰å¾…å¼¹çª—
                                    showRecoveryWaiting.value = true;
                                }
                            }
                        }
                        // åªæœ‰å½“æœ¬åœ°å­˜æœ‰æ—§çš„sessionIdï¼Œä¸”ä¸å½“å‰æœåŠ¡å™¨ä¸ä¸€è‡´æ—¶ï¼Œæ‰è§†ä¸ºé‡å¯
                        else if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                            // æœåŠ¡å™¨å·²é‡å¯ï¼Œæ¸…é™¤æ—§çš„èº«ä»½ä¿¡æ¯
                            localStorage.removeItem('turtle_uid');
                            localStorage.removeItem('turtle_role');
                            // localStorage.removeItem('turtle_nickname'); // ä¿ç•™æ˜µç§°
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¼ºåˆ¶åˆ·æ–°é¡µé¢ä»¥é‡æ–°ç™»å½•
                            alert('æœåŠ¡å™¨å·²é‡å¯ï¼Œè¯·é‡æ–°åŠ å…¥æ¸¸æˆ');
                            location.reload();
                            return;
                        }

                        // å¦‚æœæ˜¯é¦–æ¬¡è¿›å…¥ï¼ˆæ— æœ¬åœ°sessionIdï¼‰ï¼Œä¿å­˜å½“å‰çš„
                        if (!storedSessionId && state.serverSessionId) {
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                        }

                        myId.value = state.myId;
                        // ä¿å­˜èº«ä»½ä¿¡æ¯
                        if (state.userId) {
                            localStorage.setItem('turtle_uid', state.userId);
                            localStorage.setItem('turtle_nickname', nickname.value);
                        }
                        
                        players.value = state.players;
                        const me = state.players.find(p => p.id === state.myId);
                        isHost.value = me?.isHost || false;
                        persistRole(isHost.value);
                        hasHost.value = state.players.some(p => p.isHost);
                        
                        currentPuzzle.value = state.currentPuzzle;
                        history.value = state.history;
                        puzzleList.value = state.puzzles;
                        if (state.limits) {
                            gameLimits.value = state.limits;
                        }
                        if (state.startTime) {
                            gameStartTime.value = state.startTime;
                            startDurationTimer();
                        } else {
                            stopDurationTimer();
                        }
                        scrollToBottom();
                    });

                    socket.on('player_update', (list) => {
                        players.value = list;
                        const me = list.find(p => p.id === myId.value);
                        if (me) {
                            isHost.value = me.isHost;
                            persistRole(me.isHost);
                        }
                        hasHost.value = list.some(p => p.isHost);
                    });

                    socket.on('host_data', (puzzles) => {
                        puzzleList.value = puzzles;
                    });

                    socket.on('new_puzzle', (data) => {
                        // å…¼å®¹æ—§æ ¼å¼
                        if (data.title) {
                            currentPuzzle.value = data;
                        } else {
                            currentPuzzle.value = data.puzzle;
                        }
                        
                        if (data.limits) {
                            gameLimits.value = data.limits;
                        } else {
                            gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        }
                        
                        if (data.startTime) {
                            gameStartTime.value = data.startTime;
                            startDurationTimer();
                        }

                        history.value = [];
                        gameOver.value = false;
                    });

                    socket.on('puzzle_reveal', (fullPuzzle) => {
                        currentPuzzle.value = fullPuzzle;
                    });

                    socket.on('new_question', (q) => {
                        history.value.push(q);
                        scrollToBottom();
                    });

                    socket.on('question_answered', (updatedQ) => {
                        const idx = history.value.findIndex(h => h.id === updatedQ.id);
                        if (idx !== -1) {
                            history.value[idx] = updatedQ;
                        }
                    });

                    socket.on('game_over', (answer) => {
                        gameOver.value = true;
                        if (currentPuzzle.value) {
                            currentPuzzle.value.answer = answer;
                        }
                    });

                    socket.on('return_to_lobby', () => {
                        currentPuzzle.value = null;
                        history.value = [];
                        gameOver.value = false;
                        gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        gameStartTime.value = null;
                        stopDurationTimer();
                    });

                    socket.on('error_message', (data) => {
                        alert(data.message);
                    });

                    socket.on('host_transfer_request', (data) => {
                        if (confirm(`ç©å®¶ ${data.requesterName} æƒ³è¦æˆä¸ºä¸»æŒäººï¼Œæ˜¯å¦åŒæ„è½¬è®©ä¸»æŒæƒï¼Ÿ`)) {
                            socket.emit('approve_host_transfer', data.requesterId);
                        } else {
                            socket.emit('reject_host_transfer', data.requesterId);
                        }
                    });

                    socket.on('host_transfer_rejected', () => {
                        alert('ä¸»æŒäººæ‹’ç»äº†ä½ çš„ç”³è¯·');
                    });

                    socket.on('disconnect', () => {
                        serverConnected.value = false;
                        console.log('Server connection lost');
                    });

                    socket.on('reconnect', () => {
                        serverConnected.value = true;
                        console.log('Server reconnected');
                    });

                    socket.on('recovery_decision_made', (data) => {
                        showRecoveryDecision.value = false;
                        showRecoveryWaiting.value = false;
                        
                        if (!data.recover) {
                            // é€‰æ‹©é‡å¼€æ–°å±€ï¼Œåˆ·æ–°é¡µé¢
                            location.reload();
                        }
                    });
                };

                const joinGame = () => {
                    if (!nickname.value.trim()) return;
                    
                    // ç¡®ä¿è¿æ¥å·²å»ºç«‹
                    initSocket();

                    // å°è¯•è·å–æœ¬åœ°å­˜å‚¨çš„ userId
                    const storedUserId = localStorage.getItem('turtle_uid');
                    const sessionId = localStorage.getItem('turtle_session_id');
                    const roleHint = localStorage.getItem('turtle_role');
                    const payload = {
                        nickname: nickname.value,
                        userId: storedUserId,
                        sessionId,
                        roleHint
                    };

                    if (socket?.connected) {
                        socket.emit('join', payload);
                    } else {
                        pendingJoinPayload = payload;
                    }
                    joined.value = true;
                };

                const requestHost = () => {
                    if (requestHostCooldown.value) {
                        alert('è¯·ç¨åå†è¯•ï¼Œå†·å´æ—¶é—´æœªç»“æŸ');
                        return;
                    }
                    
                    socket.emit('request_host');
                    requestHostCooldown.value = true;
                    
                    setTimeout(() => {
                        requestHostCooldown.value = false;
                    }, 8000);
                };

                const selectPuzzle = (id) => {
                    socket.emit('select_puzzle', id);
                };
                
                const submitCustomPuzzle = () => {
                    if (!customForm.value.title || !customForm.value.content || !customForm.value.answer) {
                        alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                        return;
                    }
                    
                    if (!confirm('ç¡®å®šè¦ä½¿ç”¨è¿™ä¸ªè‡ªå®šä¹‰é¢˜ç›®å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                        return;
                    }

                    // æ·±æ‹·è´ä»¥é˜²æ­¢å¼•ç”¨é—®é¢˜
                    const payload = JSON.parse(JSON.stringify(customForm.value));
                    // æ·»åŠ é™åˆ¶è®¾ç½®
                    payload.maxQuestionsPerPlayer = settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null;
                    payload.maxTotalQuestions = settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null;
                    
                    socket.emit('create_custom_puzzle', payload);
                    
                    showCustomModal.value = false;
                    customForm.value = { title: '', content: '', answer: '' };
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                };

                const sendQuestion = () => {
                    if (!questionText.value.trim()) return;
                    socket.emit('ask_question', questionText.value);
                    questionText.value = '';
                    nextTick(() => {
                        const mobileInput = document.getElementById('mobile-question-input');
                        if (mobileInput) mobileInput.style.height = 'auto';
                    });
                };

                const answer = (questionId, type) => {
                    const customText = customAnswers.value[questionId];
                    socket.emit('answer_question', { 
                        questionId, 
                        answerType: type, 
                        customText 
                    });
                    // æ¸…ç†è¾“å…¥æ¡†
                    if (type === 'custom') delete customAnswers.value[questionId];
                };

                const revealAnswer = () => {
                    if(confirm('ç¡®å®šè¦æ­æ™“æ±¤åº•å¹¶ç»“æŸæœ¬å±€å—ï¼Ÿ')) {
                        socket.emit('reveal_answer');
                    }
                };

                const returnToLobby = () => {
                    if(confirm('ç¡®å®šè¦è¿”å›å¤§å…é€‰æ–°é¢˜å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                        socket.emit('return_to_lobby');
                    }
                };

                const scrollToBottom = () => {
                    nextTick(() => {
                        if (historyBox.value) {
                            historyBox.value.scrollTop = historyBox.value.scrollHeight;
                        }
                    });
                };

                // Socket Listeners
                onMounted(() => {
                    // è‡ªåŠ¨ç™»å½•æ£€æŸ¥
                    const storedNickname = localStorage.getItem('turtle_nickname');
                    const storedUserId = localStorage.getItem('turtle_uid');
                    
                    if (storedNickname) {
                        nickname.value = storedNickname;
                    }

                    if (storedNickname && storedUserId) {
                        joinGame();
                    }
                });

                const claimHost = () => {
                    socket.emit('claim_host');
                };

                const resignHost = () => {
                    if (confirm('ç¡®å®šè¦é€€å‡ºä¸»æŒäººè§’è‰²å—ï¼Ÿ')) {
                        socket.emit('resign_host');
                    }
                };

                const previewPuzzleDetails = (puzzle) => {
                    previewPuzzle.value = puzzle;
                    showPreviewModal.value = true;
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                };

                const confirmStartPuzzle = () => {
                    if (!previewPuzzle.value) return;
                    
                    const onlinePlayers = players.value.filter(p => p.isOnline);
                    if (onlinePlayers.length < 2) {
                        alert('è‡³å°‘éœ€è¦2åç©å®¶æ‰èƒ½å¼€å§‹æ¸¸æˆï¼ˆåŒ…æ‹¬ä¸»æŒäººï¼‰');
                        return;
                    }

                    const options = {
                        id: previewPuzzle.value.id,
                        maxQuestionsPerPlayer: settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null,
                        maxTotalQuestions: settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null
                    };

                    socket.emit('select_puzzle', options);
                    showPreviewModal.value = false;
                    previewPuzzle.value = null;
                };

                const recoverGame = () => {
                    socket.emit('recover_game');
                    showRecoveryDecision.value = false;
                };

                const startNewGame = () => {
                    if (confirm('ç¡®å®šè¦æ”¾å¼ƒä¸Šä¸€å±€æ¸¸æˆï¼Œå¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿ')) {
                        socket.emit('start_new_game');
                        showRecoveryDecision.value = false;
                    }
                };

                const kickPlayer = (playerId) => {
                    if (confirm('ç¡®å®šè¦è¸¢å‡ºè¯¥ç¦»çº¿ç©å®¶å—ï¼Ÿ')) {
                        socket.emit('kick_player', playerId);
                    }
                };

                return {
                    joined, nickname, myId, isHost, players, puzzleList, 
                    currentPuzzle, history, questionText, customAnswers, gameOver,
                    joinGame, requestHost, selectPuzzle, sendQuestion, answer, revealAnswer, returnToLobby,
                    historyBox, showCustomModal, customForm, submitCustomPuzzle, hasHost, claimHost, resignHost,
                    showPreviewModal, previewPuzzle, previewPuzzleDetails, confirmStartPuzzle, requestHostCooldown,
                    serverConnected, showRecoveryDecision, showRecoveryWaiting, recoverGame, startNewGame,
                    isPuzzleExpanded, autoResize, gameLimits, settingsForm, myQuestionCount, publicUsedCount, canAskQuestion, questionPlaceholder,
                    kickPlayer, gameDuration
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
