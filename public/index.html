<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ·é¾Ÿæ±¤ Online</title>
    <script src="./tailwindcss_browser@4.js"></script>
    <script src="./vue.global.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        .chat-bubble { max-width: 80%; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.5s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .styled-scrollbar{
            scroll-behavior: smooth;
            scrollbar-color: var(--color-emerald-500) var(--color-gray-800);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4 md:pb-4" style="max-width: 100rem">
        <!-- ç™»å½•ç•Œé¢ -->
        <div v-if="!joined" class="flex flex-col items-center justify-center h-screen">
            <h1 class="text-6xl font-bold mb-8 text-emerald-500">ğŸ¢ æµ·é¾Ÿæ±¤</h1>
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
                <label class="block mb-2 text-lg">è¯·è¾“å…¥æ˜µç§°</label>
                <input v-model="nickname" @keyup.enter="joinGame" type="text" class="w-full p-3 rounded bg-gray-700 border border-gray-600 focus:border-emerald-500 focus:outline-none mb-4" placeholder="ä½ çš„åå­—...">
                <button @click="joinGame" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded transition cursor-pointer">è¿›å…¥æˆ¿é—´</button>
            </div>
        </div>

        <!-- æ¸¸æˆä¸»ç•Œé¢ -->
        <div v-else>
            <!-- é¡¶éƒ¨æ  -->
            <header class="flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-lg">
                <div>
                    <h1 class="text-2xl font-bold text-emerald-500">æµ·é¾Ÿæ±¤ Online</h1>
                    <p class="text-sm text-gray-400">å½“å‰èº«ä»½: <span :class="isHost ? 'text-yellow-400 font-bold' : 'text-blue-400'">{{ isHost ? 'ä¸»æŒäºº (Host)' : 'ä¾¦æ¢ (Player)' }}</span></p>
                </div>
                <div class="flex items-center gap-4">
                    <div class="text-right">
                        <p class="text-sm">åœ¨çº¿äººæ•°: {{ players.length }}</p>
                        <p class="text-xs text-gray-500">{{ nickname }}</p>
                    </div>
                    <button v-if="!isHost && !hasHost && !currentPuzzle" @click="claimHost" class="text-xs bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-white font-bold animate-pulse">æˆä¸ºä¸»æŒäºº</button>
                    <button v-if="!isHost && hasHost && !currentPuzzle" @click="requestHost" :disabled="requestHostCooldown" :class="requestHostCooldown ? 'opacity-50 cursor-not-allowed' : ''" class="text-xs bg-emerald-600 hover:bg-emerald-700 px-2 py-1 rounded">ç”³è¯·ä¸»æŒ</button>
                    <button v-if="isHost && !currentPuzzle" @click="resignHost" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white">é€€å‡ºä¸»æŒ</button>
                </div>
            </header>

            <!-- ä¸»æŒäººé€‰æ‹©å¼¹çª— (ä»…å½“æ²¡æœ‰ä¸»æŒäººä¸”è‡ªå·±ä¸æ˜¯ä¸»æŒäººæ—¶æ˜¾ç¤º) -->
            <div v-if="!hasHost && !isHost" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <h2 class="text-3xl font-bold mb-4 text-yellow-400">ğŸ¢ è°æ¥å½“æµ·é¾Ÿï¼Ÿ</h2>
                    <p class="text-gray-300 mb-8">å½“å‰æˆ¿é—´è¿˜æ²¡æœ‰ä¸»æŒäººã€‚<br>ä½ æƒ³æˆä¸ºä¸»æŒäººå‡ºé¢˜å—ï¼Ÿ</p>
                    <div class="flex flex-col gap-4">
                        <button @click="claimHost" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 rounded transition text-lg cursor-pointer">
                            æˆ‘æ¥å½“ä¸»æŒäººï¼
                        </button>
                        <p class="text-sm text-gray-500">æˆ–è€…ç­‰å¾…å…¶ä»–äººæˆä¸ºä¸»æŒäºº...</p>
                    </div>
                </div>
            </div>
            <!-- æ¢å¤æ¸¸æˆå†³å®šå¼¹çª— (ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶) -->
            <div v-if="showRecoveryDecision" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[60]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-lg border border-blue-500 shadow-2xl">
                    <h2 class="text-3xl font-bold mb-4 text-blue-400">ğŸ”„ å‘ç°ä¸Šä¸€åœºæ¸¸æˆè®°å½•</h2>
                    <p class="text-gray-300 mb-6 text-lg">æ£€æµ‹åˆ°æœåŠ¡å™¨é‡å¯å‰æœ‰æœªå®Œæˆçš„æ¸¸æˆå¯¹å±€ï¼Œæ˜¯å¦è¦æ¢å¤ï¼Ÿ</p>
                    <div class="bg-blue-900/30 border border-blue-600 rounded p-4 mb-6">
                        <p class="text-blue-200 text-sm">âœ“ æ¢å¤æ¸¸æˆå°†ä¿ç•™æ‰€æœ‰æ¨ç†å†å²å’Œé¢˜ç›®ä¿¡æ¯</p>
                        <p class="text-blue-200 text-sm mt-2">âœ“ æ‰€æœ‰ç©å®¶å°†æ¢å¤åŸæœ‰çš„æ˜µç§°å’Œè§’è‰²</p>
                    </div>
                    <div class="flex gap-4">
                        <button @click="startNewGame" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 rounded transition cursor-pointer">
                            é‡å¼€æ–°å±€
                        </button>
                        <button @click="recoverGame" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded transition cursor-pointer">
                            æ¢å¤æ¸¸æˆ
                        </button>
                    </div>
                </div>
            </div>

            <!-- ç­‰å¾…æ¢å¤å†³å®šå¼¹çª— (å…¶ä»–ç©å®¶) -->
            <div v-if="showRecoveryWaiting" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[55]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <div class="mb-6">
                        <svg class="animate-spin h-16 w-16 text-yellow-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h2 class="text-2xl font-bold mb-4 text-yellow-400">â³ ç­‰å¾…å†³å®šä¸­...</h2>
                    <p class="text-gray-300 text-lg">å…¶ä»–ç©å®¶æ­£åœ¨å†³å®šæ˜¯å¦æ¢å¤ä¸Šä¸€åœºæ¸¸æˆ</p>
                    <p class="text-gray-500 text-sm mt-4">è¯·ç¨å€™</p>
                </div>
            </div>

            <!-- å®½å±ä¸‰åˆ—å¸ƒå±€ -->
            <div v-if="currentPuzzle" class="hidden md:flex gap-4 h-[calc(100vh-140px)]">
                <!-- å·¦ä¾§ï¼šæ±¤é¢æ±¤åº•ï¼ˆå›ºå®šï¼‰ -->
                <div class="flex w-1/3 flex-shrink-0 overflow-y-auto custom-scrollbar">
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg border-t-4 border-emerald-500 sticky top-0 overflow-y-auto styled-scrollbar">
                        <div class="flex justify-between items-start mb-2">
                            <h2 class="text-xl font-bold pr-2">{{ currentPuzzle.title }}</h2>
                            <div v-if="isHost" class="flex gap-1 shrink-0 flex-row">
                                <button v-if="!gameOver" @click="openEditModal" class="text-sm bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded text-white cursor-pointer">ç¼–è¾‘</button>
                                <button v-if="!gameOver" @click="revealAnswer" class="text-sm bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-white cursor-pointer">æ­æ™“</button>
                                <button @click="returnToLobby" class="text-sm bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded text-white cursor-pointer">è¿”å›</button>
                            </div>
                        </div>
                        
                        <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                        <div v-if="currentPuzzle.tags" class="flex gap-2 mb-3 flex-wrap">
                            <span v-if="currentPuzzle.tags.isLogical !== undefined" :class="currentPuzzle.tags.isLogical ? 'bg-blue-600' : 'bg-gray-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.isLogical ? 'âœ“ æœ¬æ ¼æ¨ç†' : 'âœ— éæœ¬æ ¼' }}</span>
                            <span v-if="currentPuzzle.tags.hasDeath !== undefined" :class="currentPuzzle.tags.hasDeath ? 'bg-red-600' : 'bg-gray-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.hasDeath ? 'âœ“ æœ‰æ­»äºº' : 'âœ— æ— æ­»äºº' }}</span>
                            <span v-if="currentPuzzle.tags.isHuman !== undefined" :class="currentPuzzle.tags.isHuman ? 'bg-green-600' : 'bg-purple-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.isHuman ? 'âœ“ äººç±»' : 'âœ— éäººç±»' }}</span>
                        </div>
                        
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-sm font-bold text-emerald-400 mb-2">æ±¤é¢ (é¢˜ç›®)</h3>
                                <p v-if="currentPuzzle.content" class="text-sm leading-relaxed text-gray-200">{{ currentPuzzle.content }}</p>
                                <div v-if="currentPuzzle.contentImages && currentPuzzle.contentImages.length > 0" class="flex flex-col gap-2 mt-2">
                                    <img v-for="(img, index) in currentPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click="openImageModal(img, currentPuzzle.contentImages, index)">
                                </div>
                            </div>
                            
                            <div v-if="isHost || gameOver" class="p-3 bg-gray-900 rounded border border-gray-700">
                                <h3 class="text-sm font-bold text-red-400 mb-2">æ±¤åº• (ç­”æ¡ˆ)</h3>
                                <p v-if="currentPuzzle.answer" class="text-sm text-gray-300">{{ currentPuzzle.answer }}</p>
                                <div v-if="currentPuzzle.answerImages && currentPuzzle.answerImages.length > 0" class="flex flex-col gap-2 mt-2">
                                    <img v-for="(img, index) in currentPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click="openImageModal(img, currentPuzzle.answerImages, index)">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ä¸­é—´ï¼šæ¨ç†è®°å½•ï¼ˆå¯æ»šåŠ¨ï¼‰ -->
                <div class="flex flex-1 overflow-y-auto custom-scrollbar rounded-lg shadow-lg">
                    <div class="flex flex-col flex-1 bg-gray-800 rounded-lg shadow-lg">
                        <h3 class="p-4 text-lg font-bold border-b border-gray-700 pb-2 pt-2 sticky top-0 bg-gray-800 z-10">æ¨ç†è®°å½•</h3>
                        <div class="grow space-y-4 grow-1 bg-gray-800 p-4 rounded-lg shadow-lg" ref="historyBox">
                            <div v-for="item in history" :key="item.id" :class="{
                                        'bg-green-700/50': item.answerType === 'yes',
                                        'bg-red-700/50': item.answerType === 'no',
                                        'bg-gray-700/50': item.answerType === 'irrelevant',
                                        'bg-orange-700/50': item.answerType === 'maybe',
                                        'bg-blue-700/50': item.answerType === 'custom',
                                        'bg-yellow-600/50': item.status === 'pending'
                                    }" class="bg-gray-700/50 p-3 rounded">
                                <div class="flex justify-between text-sm text-white/70 mb-1">
                                    <span>{{ item.nickname }}</span>
                                    <span v-if="item.status === 'pending'" class="text-yellow-500">ç­‰å¾…è®°å½•...</span>
                                </div>
                                <p class="font-medium text-white mb-2">Q: {{ item.question }}</p>
                                
                                <!-- å›ç­”åŒºåŸŸ -->
                                <div v-if="item.status === 'answered'" class="flex items-center gap-2 mt-2 pl-4 border-l-2 border-emerald-500">
                                    <span class="text-emerald-400 font-bold">A:</span>
                                    <span :class="{
                                        'text-green-400': item.answerType === 'yes',
                                        'text-red-400': item.answerType === 'no',
                                        'text-gray-400': item.answerType === 'irrelevant',
                                        'text-orange-400': item.answerType === 'maybe',
                                        'text-blue-400': item.answerType === 'custom'
                                    }">{{ item.answer }}</span>
                                </div>

                                <!-- ä¸»æŒäººæ“ä½œåŒº -->
                                <div v-if="isHost && item.status === 'pending'" class="mt-2 flex gap-2 flex-wrap flex-col">
                                    <div class="mb-2">
                                        <label class="block text-xs text-gray-400 mb-1">TAæƒ³é—®çš„é—®é¢˜:</label>
                                        <input v-model="questionInputs[item.id]" placeholder="è¯·è¾“å…¥ç©å®¶æƒ³é—®çš„å…·ä½“é—®é¢˜..." class="w-full bg-gray-900 text-base px-3 py-2 rounded border border-yellow-600 focus:border-yellow-400 focus:outline-none">
                                    </div>
                                    <div class="flex justify-between gap-2">
                                        <button @click="answer(item.id, 'yes')" class="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-sm flex-grow cursor-pointer">æ˜¯</button>
                                        <button @click="answer(item.id, 'no')" class="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-sm flex-grow cursor-pointer">ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'maybe')" class="px-2 py-1 bg-orange-600 hover:bg-orange-700 rounded text-sm flex-grow cursor-pointer">æ˜¯æˆ–ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'irrelevant')" class="px-2 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm flex-grow cursor-pointer">ä¸é‡è¦</button>
                                    </div>
                                    <div class="flex justify-between gap-2">
                                        <input v-model="customAnswers[item.id]" placeholder="è‡ªå®šä¹‰å›ç­”" class="bg-gray-900 text-base px-2 py-1 rounded border border-gray-600 w-46 flex-grow-2">
                                        <button @click="answer(item.id, 'custom')" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded text-base flex-grow cursor-pointer">å‘é€</button>
                                    </div>
                                </div>
                            </div>
                            <div v-if="gameOver" class="bg-red-900/30 border border-red-600 rounded p-3 text-center">
                                <p class="text-red-400 font-bold text-base">ğŸ æœ¬å±€æ¸¸æˆå·²ç»“æŸ</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- å³ä¾§ï¼šç©å®¶åˆ—è¡¨å’ŒçŒœæµ‹æ¨¡å—ï¼ˆå›ºå®šï¼‰ -->
                <div class="w-1/6 flex flex-col space-y-4"> 
                    <div v-if="!isHost && !gameOver" class="bg-gray-800 p-4 rounded-lg shadow-lg">
                        <h3 class="font-bold text-emerald-400 flex justify-between items-center text-sm">
                            <span>çŒœæµ‹</span>
                        </h3>
                        <div class="text-center pt-3">
                            <p class="text-gray-400 text-xs mb-3">ç‚¹å‡»æŒ‰é’®å‘èµ·çŒœæµ‹è¯·æ±‚<br>ä¸»æŒäººå°†ä¸ºæ‚¨è¾“å…¥å…·ä½“é—®é¢˜</p>
                            <button @click="sendQuestion" :disabled="!canAskQuestion"
                                class="w-full bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold py-3 rounded transition cursor-pointer text-base">
                                ğŸ¤” æˆ‘è¦çŒœæµ‹
                            </button>
                            <p v-if="!canAskQuestion" class="text-red-400 text-xs mt-2">{{ questionPlaceholder }}</p>
                        </div>
                    </div>
                    <div class="grow-2 bg-gray-800 p-4 rounded-lg shadow-lg overflow-y-auto styled-scrollbar">
                        <div class="sticky top-0">
                                <h3 class="font-bold mb-2 text-gray-400 text-sm flex justify-between items-center bg-gray-800 pb-2">
                                <span>åœ¨çº¿ç©å®¶</span>
                                <span v-if="gameDuration" class="text-xs text-emerald-400 font-mono">{{ gameDuration }}</span>
                            </h3>
                            <div v-if="!gameOver && (gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions)" :class="[shouldHighlightRemaining ? 'font-bold animate-pulse bg-yellow-600/50' : 'text-gray-400']" class="mb-3 p-2 bg-gray-700/50 rounded border border-gray-600">
                                <p :class="[shouldHighlightRemaining ? 'text-yellow-300' : 'text-gray-400']" class="text-xs mb-1">å‰©ä½™æé—®æ¬¡æ•°:</p>
                                <div class="text-xs">
                                    <span v-if="isHost && gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                        ä¸ªäººä¸Šé™: {{ gameLimits.maxQuestionsPerPlayer }}
                                    </span>
                                    <span v-if="!isHost && gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                        ä¸ªäºº: <span class="font-bold">{{ remainingCounts?.personalRemaining }}</span>/{{ gameLimits.maxQuestionsPerPlayer }}
                                    </span>
                                    <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions" class="text-gray-500 mx-1"> |</span>
                                    <span v-if="gameLimits.maxTotalQuestions" class="text-emerald-400">
                                        å…¬å…±: <span class="font-bold">{{ remainingCounts?.publicRemaining }}</span>/{{ gameLimits.maxTotalQuestions }}
                                    </span>
                                </div>
                            </div>
                            <div v-if="gameOver" class="sticky top-0 bg-red-900/30 border border-red-600 rounded p-3 text-center">
                                <p class="text-red-400 font-bold text-base">ğŸ æœ¬å±€æ¸¸æˆå·²ç»“æŸ</p>
                                <div v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" class="text-gray-400 text-sm mt-2">
                                    å‰©ä½™æé—®æ¬¡æ•°: <br>
                                    <span v-if="isHost && gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                        ä¸ªäººä¸Šé™: {{ gameLimits.maxQuestionsPerPlayer }}
                                    </span>
                                    <span v-if="!isHost && remainingCounts && remainingCounts.personalTotal !== null" class="text-blue-400 font-bold">{{ remainingCounts.personalRemaining }} (ä¸ªäºº) </span>
                                    <span v-if="remainingCounts && remainingCounts.personalTotal !== null && remainingCounts.publicTotal !== null"> + </span>
                                    <span v-if="remainingCounts && remainingCounts.publicTotal !== null" class="text-emerald-400 font-bold">{{ remainingCounts.publicRemaining }} (å…¬å…±) </span>
                                </div>
                            </div>
                        </div>
                        <ul class="space-y-1 text-xs mt-4">
                            <li v-for="p in players" :key="p.id" class="flex items-center gap-2" :class="{'opacity-50': !p.isOnline}">
                                <span class="w-2 h-2 rounded-full" :class="[p.isOnline ? (p.isHost ? 'bg-yellow-400' : 'bg-green-400') : 'bg-gray-500']"></span>
                                <span :class="{'text-yellow-400': p.isHost}">{{ p.nickname }}</span>
                                <span v-if="!p.isHost && p.remainingCounts && (gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions)" class="text-xs text-gray-400">
                                    <template v-if="p.remainingCounts.personalTotal !== null">
                                        ({{ p.remainingCounts.personalRemaining }}/{{ p.remainingCounts.personalTotal }})
                                    </template>
                                </span>
                                <span v-if="!p.isOnline" class="text-xs text-red-400">(ç¦»çº¿)</span>
                                <span v-if="p.id === myId" class="text-gray-500 text-xs">(æˆ‘)</span>
                                <button v-if="isHost && !p.isOnline" @click="kickPlayer(p.id)" class="ml-auto text-xs bg-red-800/80 hover:bg-red-700 text-white px-2 py-1 rounded border border-red-700 transition cursor-pointer" title="è¸¢å‡ºè¯¥ç©å®¶">è¸¢å‡º</button>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- ç§»åŠ¨ç«¯å’Œé€‰é¢˜ç•Œé¢ä¿æŒåŸæœ‰å¸ƒå±€ -->
            <div :class="currentPuzzle ? 'md:hidden' : ''" class="grid grid-cols-1 md:grid-cols-4 gap-6">
                
                <!-- å·¦ä¾§/ä¸Šæ–¹ï¼šé¢˜ç›®åŒºåŸŸ -->
                <div class="md:col-span-3 space-y-6">
                    <!-- é€‰é¢˜åŒºåŸŸ (ä»…ä¸»æŒäººä¸”æ— é¢˜ç›®æ—¶æ˜¾ç¤º) -->
                    <div v-if="isHost && !currentPuzzle" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold text-yellow-400">é€‰æ‹©ä¸€ä¸ªæ±¤é¢</h2>
                            <button @click="showCustomModal = true" class="text-sm bg-emerald-600 hover:bg-emerald-700 px-3 py-1 rounded text-white transition cursor-pointer">+ è‡ªå®šä¹‰</button>
                        </div>
                        <div class="space-y-2 max-h-96 overflow-y-auto styled-scrollbar">
                            <div v-for="p in puzzleList" :key="p.id" @click="previewPuzzleDetails(p)" 
                                class="p-4 bg-gray-700 hover:bg-gray-600 rounded cursor-pointer transition border-l-4 border-transparent hover:border-yellow-400">
                                <h3 class="font-bold">{{ p.title }}</h3>
                                <p class="text-sm text-gray-400 truncate">{{ p.content }}</p>
                                <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                                <div v-if="p.tags" class="flex gap-2 mt-2 flex-wrap">
                                    <span v-if="p.tags.isLogical !== undefined" :class="p.tags.isLogical ? 'bg-blue-600' : 'bg-gray-600'" class="text-xs px-2 py-0.5 rounded">{{ p.tags.isLogical ? 'âœ“ æœ¬æ ¼æ¨ç†' : 'âœ— éæœ¬æ ¼' }}</span>
                                    <span v-if="p.tags.hasDeath !== undefined" :class="p.tags.hasDeath ? 'bg-red-600' : 'bg-gray-600'" class="text-xs px-2 py-0.5 rounded">{{ p.tags.hasDeath ? 'âœ“ æœ‰æ­»äºº' : 'âœ— æ— æ­»äºº' }}</span>
                                    <span v-if="p.tags.isHuman !== undefined" :class="p.tags.isHuman ? 'bg-green-600' : 'bg-purple-600'" class="text-xs px-2 py-0.5 rounded">{{ p.tags.isHuman ? 'âœ“ äººç±»' : 'âœ— éäººç±»' }}</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ç­‰å¾…é¢˜ç›®-->
                    <div v-if="!currentPuzzle && !isHost" class="bg-gray-800 p-12 rounded-lg text-center text-gray-500">
                        <p class="text-xl">ç­‰å¾…ä¸»æŒäººå‡ºé¢˜...</p>
                    </div>

                    <!-- é¢˜ç›®é¢„è§ˆæ¨¡æ€æ¡† -->
                    <div v-if="showPreviewModal && previewPuzzle" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-2xl border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto styled-scrollbar">
                            <h3 class="text-2xl font-bold mb-4 text-yellow-400">{{ previewPuzzle.title }}</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-bold text-emerald-400 mb-2">æ±¤é¢ (é¢˜ç›®)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        <p v-if="previewPuzzle.content">{{ previewPuzzle.content }}</p>
                                        <div v-if="previewPuzzle.contentImages && previewPuzzle.contentImages.length > 0" class="flex flex-col gap-2 mt-2">
                                            <img v-for="(img, index) in previewPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click.stop="openImageModal(img, previewPuzzle.contentImages, index)">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-red-400 mb-2">æ±¤åº• (ç­”æ¡ˆ)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        <p v-if="previewPuzzle.answer">{{ previewPuzzle.answer }}</p>
                                        <div v-if="previewPuzzle.answerImages && previewPuzzle.answerImages.length > 0" class="flex flex-col gap-2 mt-2">
                                            <img v-for="(img, index) in previewPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click.stop="openImageModal(img, previewPuzzle.answerImages, index)">
                                        </div>
                                    </div>
                                </div>
                                <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3 text-sm text-yellow-200">
                                    <p>ğŸ’¡ æç¤º: ç©å®¶åªèƒ½çœ‹åˆ°æ±¤é¢ï¼Œä¸ä¼šçœ‹åˆ°æ±¤åº•ã€‚è¯·ç¡®è®¤æ­¤é¢˜ç›®åˆé€‚åå†å¼€å§‹æ¸¸æˆã€‚</p>
                                </div>
                                
                                <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-blue-400 mb-3 text-sm">é¢˜ç›®æ ‡ç­¾</h4>
                                    <div class="grid grid-cols-3 gap-3">
                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" id="preview-logical" v-model="previewTags.isLogical" class="w-4 h-4 cursor-pointer">
                                            <label for="preview-logical" class="text-sm cursor-pointer">æœ¬æ ¼æ¨ç†</label>
                                        </div>
                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" id="preview-death" v-model="previewTags.hasDeath" class="w-4 h-4 cursor-pointer">
                                            <label for="preview-death" class="text-sm cursor-pointer">æœ‰æ­»äºº</label>
                                        </div>
                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" id="preview-human" v-model="previewTags.isHuman" class="w-4 h-4 cursor-pointer">
                                            <label for="preview-human" class="text-sm cursor-pointer">æ˜¯äººç±»</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showPreviewModal = false; previewPuzzle = null;" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="confirmStartPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                            </div>
                        </div>
                    </div>

                    <!-- é¢˜ç›®æ˜¾ç¤ºåŒºåŸŸ (ç§»åŠ¨ç«¯) -->
                    <div v-if="currentPuzzle" class="md:hidden bg-gray-800 p-6 -mx-4 rounded-none shadow-lg border-t-4 border-emerald-500 sticky top-0 z-30 transition-all">
                        <div class="flex justify-between items-start mb-2">
                            <h2 class="text-2xl font-bold truncate pr-2">{{ currentPuzzle.title }}</h2>
                            <div v-if="isHost" class="flex gap-2 shrink-0">
                                <button @click="openEditModal" v-if="!gameOver" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-white cursor-pointer">ç¼–è¾‘</button>
                                <button @click="revealAnswer" v-if="!gameOver" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white cursor-pointer">æ­æ™“</button>
                                <button @click="returnToLobby" class="text-xs bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded text-white cursor-pointer">è¿”å›</button>
                            </div>
                        </div>
                        
                        <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                        <div v-if="currentPuzzle.tags" class="flex gap-2 mb-3 flex-wrap">
                            <span v-if="currentPuzzle.tags.isLogical !== undefined" :class="currentPuzzle.tags.isLogical ? 'bg-blue-600' : 'bg-gray-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.isLogical ? 'âœ“ æœ¬æ ¼æ¨ç†' : 'âœ— éæœ¬æ ¼' }}</span>
                            <span v-if="currentPuzzle.tags.hasDeath !== undefined" :class="currentPuzzle.tags.hasDeath ? 'bg-red-600' : 'bg-gray-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.hasDeath ? 'âœ“ æœ‰æ­»äºº' : 'âœ— æ— æ­»äºº' }}</span>
                            <span v-if="currentPuzzle.tags.isHuman !== undefined" :class="currentPuzzle.tags.isHuman ? 'bg-green-600' : 'bg-purple-600'" class="text-xs px-2 py-1 rounded">{{ currentPuzzle.tags.isHuman ? 'âœ“ äººç±»' : 'âœ— éäººç±»' }}</span>
                        </div>

                        <!-- ç§»åŠ¨ç«¯è§†å›¾ (å¯æŠ˜å ) -->
                        <div>
                            <div class="cursor-pointer group" @click="togglePuzzleExpanded">
                                <p v-if="currentPuzzle.content" :class="{'line-clamp-1': !isPuzzleExpanded}" class="text-lg leading-relaxed text-gray-200 mb-1 transition-all">{{ currentPuzzle.content }}</p>
                                <div v-if="currentPuzzle.contentImages && currentPuzzle.contentImages.length > 0 && isPuzzleExpanded" class="flex flex-col gap-2 mb-2">
                                    <img v-for="(img, index) in currentPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600" @click.stop="openImageModal(img, currentPuzzle.contentImages, index)">
                                </div>
                                <p v-if="!isPuzzleExpanded" class="text-xs text-gray-500 text-center mt-1 group-hover:text-emerald-400">â–¼ ç‚¹å‡»å±•å¼€</p>
                                <p v-else class="text-xs text-gray-500 text-center mt-2">â–² ç‚¹å‡»æ”¶èµ·</p>
                            </div>
                            
                            <div v-if="(isHost || gameOver) && isPuzzleExpanded" class="mt-2 cursor-pointer" @click="toggleAnswerExpanded">
                                <div class="p-3 bg-gray-900 rounded border border-gray-700 text-base">
                                    <h3 class="font-bold text-red-400 mb-1 flex justify-between items-center">
                                        <span>æ±¤åº•:</span>
                                        <span class="text-xs text-gray-500 font-normal">{{ isAnswerExpanded ? 'â–² ç‚¹å‡»æ”¶èµ·' : 'â–¼ ç‚¹å‡»å±•å¼€' }}</span>
                                    </h3>
                                    <div v-if="isAnswerExpanded">
                                        <p v-if="currentPuzzle.answer" class="text-gray-300 mb-2">{{ currentPuzzle.answer }}</p>
                                        <div v-if="currentPuzzle.answerImages && currentPuzzle.answerImages.length > 0" class="flex flex-col gap-2">
                                            <img v-for="(img, index) in currentPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600" @click.stop="openImageModal(img, currentPuzzle.answerImages, index)">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <!-- æ¨ç†è®°å½• (ç§»åŠ¨ç«¯) -->
                    <div v-if="currentPuzzle" class="md:hidden bg-gray-800 p-4 rounded-lg shadow-lg min-h-[400px] flex flex-col">
                        <h3 class="text-lg font-bold mb-4 border-b border-gray-700 pb-2">æ¨ç†è®°å½•</h3>
                        <div class="flex-1 overflow-y-auto space-y-4 pr-2 custom-scrollbar styled-scrollbar" ref="historyBox">
                            <div v-for="item in history" :key="item.id" :class="{
                                        'bg-green-700/50': item.answerType === 'yes',
                                        'bg-red-700/50': item.answerType === 'no',
                                        'bg-gray-700/50': item.answerType === 'irrelevant',
                                        'bg-orange-550/50': item.answerType === 'maybe',
                                        'bg-blue-700/50': item.answerType === 'custom',
                                        'bg-yellow-600/50': item.status === 'pending'
                                    }" class="bg-gray-700/50 p-3 rounded">
                                <div class="flex justify-between text-sm text-white/70 mb-1">
                                    <span>{{ item.nickname }}</span>
                                    <span v-if="item.status === 'pending'" class="text-yellow-500">ç­‰å¾…å›ç­”...</span>
                                </div>
                                <p class="font-medium text-white mb-2">Q: {{ item.question }}</p>
                                
                                <!-- å›ç­”åŒºåŸŸ -->
                                <div v-if="item.status === 'answered'" class="flex items-center gap-2 mt-2 pl-4 border-l-2 border-emerald-500">
                                    <span class="text-emerald-400 font-bold">A:</span>
                                    <span :class="{
                                        'text-green-400': item.answerType === 'yes',
                                        'text-red-400': item.answerType === 'no',
                                        'text-gray-400': item.answerType === 'irrelevant',
                                        'text-orange-400': item.answerType === 'maybe',
                                        'text-blue-400': item.answerType === 'custom'
                                    }">{{ item.answer }}</span>
                                </div>

                                <!-- ä¸»æŒäººæ“ä½œåŒº -->
                                <div v-if="isHost && item.status === 'pending'" class="mt-2 flex gap-2 flex-wrap flex-col">
                                    <div class="mb-2">
                                        <label class="block text-sm text-gray-400 mb-1">TAæƒ³é—®çš„é—®é¢˜:</label>
                                        <input v-model="questionInputs[item.id]" placeholder="è¯·è¾“å…¥ç©å®¶æƒ³é—®çš„å…·ä½“é—®é¢˜..." class="w-full bg-gray-900 text-base px-3 py-2 rounded border border-yellow-600 focus:border-yellow-400 focus:outline-none">
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <button @click="answer(item.id, 'yes')" class="px-2 py-3 bg-green-600 hover:bg-green-700 rounded text-sm cursor-pointer">æ˜¯</button>
                                        <button @click="answer(item.id, 'no')" class="px-2 py-3 bg-red-600 hover:bg-red-700 rounded text-sm cursor-pointer">ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'maybe')" class="px-2 py-3 bg-orange-600 hover:bg-orange-700 rounded text-sm cursor-pointer">æ˜¯æˆ–ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'irrelevant')" class="px-2 py-3 bg-gray-600 hover:bg-gray-500 rounded text-sm cursor-pointer">ä¸é‡è¦</button>
                                    </div>
                                    <div class="flex justify-between gap-2">
                                        <input v-model="customAnswers[item.id]" placeholder="è‡ªå®šä¹‰å›ç­”" class="bg-gray-900 text-base px-2 py-2 rounded border border-gray-600 w-46 flex-grow-2">
                                        <button @click="answer(item.id, 'custom')" class="px-2 py-2 bg-blue-600 hover:bg-blue-700 rounded text-base flex-grow cursor-pointer">å‘é€</button>
                                    </div>
                                </div>
                            </div>
                            <div v-if="gameOver" class="bg-red-900/30 border border-red-600 rounded p-3 text-center">
                                <p class="text-red-400 font-bold text-base">ğŸ æœ¬å±€æ¸¸æˆå·²ç»“æŸ</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§/ä¸‹æ–¹ï¼šç©å®¶åˆ—è¡¨-->
                <div class="md:col-span-1">
                    <div :class="!isHost ? 'mb-25' : ''" class="bg-gray-800 p-4 rounded-lg shadow-lg">
                        <div>
                            <h3 class="font-bold mb-2 text-gray-400 text-base flex justify-between items-center">
                                <span>åœ¨çº¿ç©å®¶</span>
                                <span v-if="gameDuration" class="text-sm text-emerald-400 font-mono">{{ gameDuration }}</span>
                            </h3>
                            <!-- ä¸»æŒäººæŸ¥çœ‹å‰©ä½™æ¬¡æ•° -->
                            <div v-if="isHost && currentPuzzle && (gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions)" class="mb-3 p-2 bg-gray-700/50 rounded border border-gray-600">
                                <p class="text-xs text-gray-400 mb-1">å‰©ä½™æé—®æ¬¡æ•°:</p>
                                    <div class="text-sm">
                                        <span v-if="isHost && gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                            ä¸ªäººä¸Šé™: {{ gameLimits.maxQuestionsPerPlayer }}
                                        </span>
                                        <span v-if="!isHost && gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                            ä¸ªäºº: <span class="font-bold">{{ remainingCounts?.personalRemaining }}</span>/{{ gameLimits.maxQuestionsPerPlayer }}
                                        </span>
                                        <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions" class="text-gray-500 mx-1"> |</span>
                                        <span v-if="gameLimits.maxTotalQuestions" class="text-emerald-400">
                                            å…¬å…±: <span class="font-bold">{{ remainingCounts?.publicRemaining }}</span>/{{ gameLimits.maxTotalQuestions }}
                                        </span>
                                    </div>
                            </div>
                            <ul class="space-y-1 text-sm">
                                <li v-for="p in players" :key="p.id" class="flex items-center gap-2" :class="{'opacity-50': !p.isOnline}">
                                    <span class="w-2 h-2 rounded-full" :class="[p.isOnline ? (p.isHost ? 'bg-yellow-400' : 'bg-green-400') : 'bg-gray-500']"></span>
                                    <span :class="{'text-yellow-400': p.isHost}">{{ p.nickname }}</span>
                                    <span v-if="!p.isHost && p.remainingCounts && currentPuzzle && (gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions)" class="text-xs text-gray-400">
                                        <template v-if="p.remainingCounts.personalTotal !== null">
                                            ({{ p.remainingCounts.personalRemaining }}/{{ p.remainingCounts.personalTotal }})
                                        </template>
                                    </span>
                                    <span v-if="!p.isOnline" class="text-xs text-red-400">(ç¦»çº¿)</span>
                                    <span v-if="p.id === myId" class="text-gray-500 text-xs">(æˆ‘)</span>
                                    <button v-if="isHost && !p.isOnline" @click="kickPlayer(p.id)" class="ml-auto text-xs bg-red-900/80 hover:bg-red-700 text-white px-2 py-1 rounded border border-red-700 transition cursor-pointer" title="è¸¢å‡ºè¯¥ç©å®¶">è¸¢å‡º</button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ç§»åŠ¨ç«¯åº•éƒ¨çŒœæµ‹æŒ‰é’® -->
        <div v-if="!isHost && currentPuzzle" class="md:hidden fixed bottom-0 left-0 right-0 bg-gray-800 p-3 border-t border-gray-700 z-40 flex flex-col gap-2 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)]">
            <!-- æ¸¸æˆç»“æŸæç¤º -->
            <div v-if="gameOver" class="bg-red-900/30 border border-red-600 rounded p-3 text-center">
                <p class="text-red-400 font-bold text-base">ğŸ æœ¬å±€æ¸¸æˆå·²ç»“æŸ</p>
                <div v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" class="text-gray-400 text-sm">
                    å‰©ä½™: 
                    <span v-if="remainingCounts && remainingCounts.personalTotal !== null" class="text-blue-400 font-bold">{{ remainingCounts.personalRemaining }} (ä¸ªäºº) </span>
                    <span v-if="remainingCounts && remainingCounts.personalTotal !== null && remainingCounts.publicTotal !== null"> + </span>
                    <span v-if="remainingCounts && remainingCounts.publicTotal !== null" class="text-emerald-400 font-bold">{{ remainingCounts.publicRemaining }} (å…¬å…±) </span>
                </div>
            </div>
            
            <!-- æ¸¸æˆè¿›è¡Œä¸­çš„çŒœæµ‹ç•Œé¢ -->
            <template v-if="!gameOver">
                <div v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" :class="[shouldHighlightRemaining ? 'text-yellow-300 font-bold animate-pulse bg-yellow-600/50 rounded' : 'text-gray-400']" class="text-sm text-center px-1">
                    å‰©ä½™: 
                    <span v-if="remainingCounts && remainingCounts.personalTotal !== null" class="text-blue-400 font-bold">{{ remainingCounts.personalRemaining }} (ä¸ªäºº) </span>
                    <span v-if="remainingCounts && remainingCounts.personalTotal !== null && remainingCounts.publicTotal !== null"> + </span>
                    <span v-if="remainingCounts && remainingCounts.publicTotal !== null" class="text-emerald-400 font-bold">{{ remainingCounts.publicRemaining }} (å…¬å…±) </span>
                </div>
                <button @click="sendQuestion" :disabled="!canAskQuestion" 
                    class="w-full bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold py-3 rounded transition text-base cursor-pointer">
                    ğŸ¤” æˆ‘è¦çŒœæµ‹
                </button>
                <p v-if="!canAskQuestion" class="text-red-400 text-xs text-center">{{ questionPlaceholder }}</p>
            </template>
        </div>

        <!-- ç¼–è¾‘é¢˜ç›®æ¨¡æ€æ¡† -->
        <div v-if="showEditModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg w-full max-w-2xl border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto styled-scrollbar">
                <h3 class="text-xl font-bold mb-4 text-blue-500">ç¼–è¾‘é¢˜ç›®</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ ‡é¢˜</label>
                        <input v-model="editForm.title" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="ä¾‹å¦‚ï¼šææ€–çš„ç”µæ¢¯">
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ±¤é¢ (é¢˜ç›®) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                        <textarea v-model="editForm.content" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="æè¿°ç©å®¶çœ‹åˆ°çš„æƒ…æ™¯... (å¯é€‰)"></textarea>
                        <div class="mt-2">
                            <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                            <input type="file" @change="handleEditContentImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer">
                            <div v-if="editForm.contentImages && editForm.contentImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                <div v-for="(img, index) in editForm.contentImages" :key="index" class="relative group">
                                    <img @click.stop="openImageModal(img, editForm.contentImages, index)" :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                    <button @click="removeEditContentImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ±¤åº• (ç­”æ¡ˆ) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                        <textarea v-model="editForm.answer" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="äº‹æƒ…çš„çœŸç›¸æ˜¯... (å¯é€‰)"></textarea>
                        <div class="mt-2">
                            <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                            <input type="file" @change="handleEditAnswerImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer">
                            <div v-if="editForm.answerImages && editForm.answerImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                <div v-for="(img, index) in editForm.answerImages" :key="index" class="relative group">
                                    <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                    <button @click="removeEditAnswerImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                    <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                        <h4 class="font-bold text-blue-400 mb-3 text-sm">é¢˜ç›®æ ‡ç­¾</h4>
                        <div class="grid grid-cols-3 gap-3">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="edit-logical" v-model="editForm.tags.isLogical" class="w-4 h-4 cursor-pointer">
                                <label for="edit-logical" class="text-sm cursor-pointer">æœ¬æ ¼æ¨ç†</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="edit-death" v-model="editForm.tags.hasDeath" class="w-4 h-4 cursor-pointer">
                                <label for="edit-death" class="text-sm cursor-pointer">æœ‰æ­»äºº</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="edit-human" v-model="editForm.tags.isHuman" class="w-4 h-4 cursor-pointer">
                                <label for="edit-human" class="text-sm cursor-pointer">æ˜¯äººç±»</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- æ¸¸æˆè®¾ç½® -->
                    <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                        <h4 class="font-bold text-blue-400 mb-3 text-sm">æ¬¡æ•°é™åˆ¶</h4>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                <input v-model="editForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-blue-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                <input v-model="editForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-blue-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button @click="showEditModal = false" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                    <button @click="submitEditPuzzle" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-bold transition cursor-pointer">ä¿å­˜ä¿®æ”¹</button>
                </div>
            </div>
        </div>

        <!-- è‡ªå®šä¹‰é¢˜ç›®æ¨¡æ€æ¡† -->
        <div v-if="showCustomModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg w-full max-w-2xl border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto styled-scrollbar">
                <h3 class="text-xl font-bold mb-4 text-emerald-500">è‡ªå®šä¹‰æµ·é¾Ÿæ±¤</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ ‡é¢˜</label>
                        <input v-model="customForm.title" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="ä¾‹å¦‚ï¼šææ€–çš„ç”µæ¢¯">
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ±¤é¢ (é¢˜ç›®) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                        <textarea v-model="customForm.content" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="æè¿°ç©å®¶çœ‹åˆ°çš„æƒ…æ™¯... (å¯é€‰)"></textarea>
                        <div class="mt-2">
                            <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                            <input type="file" @change="handleContentImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700 file:cursor-pointer">
                            <div v-if="customForm.contentImages && customForm.contentImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                <div v-for="(img, index) in customForm.contentImages" :key="index" class="relative group">
                                    <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                    <button @click="removeContentImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">æ±¤åº• (ç­”æ¡ˆ) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                        <textarea v-model="customForm.answer" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="äº‹æƒ…çš„çœŸç›¸æ˜¯... (å¯é€‰)"></textarea>
                        <div class="mt-2">
                            <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                            <input type="file" @change="handleAnswerImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700 file:cursor-pointer">
                            <div v-if="customForm.answerImages && customForm.answerImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                <div v-for="(img, index) in customForm.answerImages" :key="index" class="relative group">
                                    <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                    <button @click="removeAnswerImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ä¸‰å¤§é—®é¢˜æ ‡ç­¾ -->
                    <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                        <h4 class="font-bold text-blue-400 mb-3 text-sm">é¢˜ç›®æ ‡ç­¾</h4>
                        <div class="grid grid-cols-3 gap-3">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="custom-logical" v-model="customForm.tags.isLogical" class="w-4 h-4 cursor-pointer">
                                <label for="custom-logical" class="text-sm cursor-pointer">æœ¬æ ¼æ¨ç†</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="custom-death" v-model="customForm.tags.hasDeath" class="w-4 h-4 cursor-pointer">
                                <label for="custom-death" class="text-sm cursor-pointer">æœ‰æ­»äºº</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="custom-human" v-model="customForm.tags.isHuman" class="w-4 h-4 cursor-pointer">
                                <label for="custom-human" class="text-sm cursor-pointer">æ˜¯äººç±»</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- æ¸¸æˆè®¾ç½® -->
                    <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                        <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button @click="showCustomModal = false" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                    <button @click="submitCustomPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                </div>
            </div>
        </div>

        <!-- å›¾ç‰‡æŸ¥çœ‹æ¨¡æ€æ¡† -->
        <div v-if="showImageModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-[70] select-none" @wheel.prevent="handleWheel">
            <!-- å·¦ä¾§åˆ‡æ¢åŒºåŸŸ -->
            <div v-if="currentImageList.length > 1 && imageScale === 1" @click="prevImage" class="absolute left-0 top-0 bottom-0 w-1/4 cursor-pointer hover:bg-white/5 transition flex items-center justify-start pl-4 z-[75]">
                <span class="text-white text-4xl opacity-50 hover:opacity-100 transition">â€¹</span>
            </div>
            
            <!-- ä¸­é—´å›¾ç‰‡åŒºåŸŸ -->
            <div class="flex-1 flex items-center justify-center" @click="handleBackgroundClick">
                <div class="max-w-[95vw] max-h-[95vh] relative overflow-hidden" @touchstart="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd">
                    <img 
                        ref="zoomableImage"
                        :src="currentImageSrc" 
                        class="max-h-[95vh] object-contain transition-transform" 
                        :class="[
                            imageScale === 1 ? 'cursor-pointer' : 'cursor-move',
                            isSvgImage ? '' : 'max-w-full'
                        ]"
                        :style="{
                            transform: `scale(${imageScale}) translate(${imageTranslate.x}px, ${imageTranslate.y}px)`,
                            '-webkit-user-drag': 'none',
                            'touch-action': 'none',
                            width: isSvgImage ? svgWidth : 'auto'
                        }"
                        @dblclick="handleDoubleClick"
                        @mousedown="handleMouseDown"
                        @click.stop
                    >
                    <button @click.stop="closeImageModal" class="absolute top-4 right-4 opacity-45 bg-red-600 hover:bg-red-700 hover:opacity-100 text-white rounded-full w-10 h-10 text-2xl cursor-pointer z-10">Ã—</button>
                    <!-- å›¾ç‰‡è®¡æ•° -->
                    <div v-if="currentImageList.length > 1" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/70 text-white px-4 py-2 rounded-full text-sm pointer-events-none">
                        {{ currentImageIndex + 1 }} / {{ currentImageList.length }}
                    </div>
                    <!-- ç¼©æ”¾æç¤º -->
                    <div v-if="imageScale > 1" class="absolute top-4 left-4 bg-black/70 text-white px-3 py-1 rounded-full text-xs pointer-events-none">
                        {{ Math.round(imageScale * 100) }}%
                    </div>
                </div>
            </div>
            
            <!-- å³ä¾§åˆ‡æ¢åŒºåŸŸ -->
            <div v-if="currentImageList.length > 1 && imageScale === 1" @click="nextImage" class="absolute right-0 top-0 bottom-0 w-1/4 cursor-pointer hover:bg-white/5 transition flex items-center justify-end pr-4">
                <span class="text-white text-4xl opacity-50 hover:opacity-100 transition">â€º</span>
            </div>
        </div>

        <!-- æœåŠ¡å™¨æ–­å¼€è¿æ¥è­¦å‘Š -->
        <div v-if="!serverConnected && !showRecoveryDecision && !showRecoveryWaiting" class="fixed bottom-0 left-0 right-0 bg-red-600 text-white py-3 px-4 shadow-lg z-50 animate-pulse">
            <div class="container mx-auto flex items-center justify-center gap-3">
                <span class="font-bold text-lg">âš ï¸ æœåŠ¡å™¨è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...</span>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, nextTick, computed } = Vue;
        let socket; // å»¶è¿Ÿåˆå§‹åŒ–
        let pendingJoinPayload = null; // åœ¨è¿æ¥å»ºç«‹å‰ç¼“å­˜ join è¯·æ±‚

        createApp({
            setup() {
                const joined = ref(false);
                const nickname = ref('');
                const myId = ref('');
                const isHost = ref(false);
                const players = ref([]);
                const puzzleList = ref([]);
                const currentPuzzle = ref(null);
                const history = ref([]);
                const questionText = ref('');
                const customAnswers = ref({});
                const questionInputs = ref({});  // å­˜å‚¨ä¸»æŒäººä¸ºæ¯ä¸ªçŒœæµ‹è¾“å…¥çš„é—®é¢˜
                const gameOver = ref(false);
                const historyBox = ref(null);
                const zoomableImage = ref(null);
                
                // è‡ªå®šä¹‰é¢˜ç›®ç›¸å…³
                const showCustomModal = ref(false);
                const customForm = ref({ 
                    title: '', 
                    content: '', 
                    answer: '', 
                    contentImages: [], 
                    answerImages: [],
                    tags: { isLogical: false, hasDeath: false, isHuman: true }
                });
                const hasHost = ref(false); // æ˜¯å¦å·²æœ‰ä¸»æŒäºº
                
                // ç¼–è¾‘é¢˜ç›®ç›¸å…³
                const showEditModal = ref(false);
                const editForm = ref({ 
                    title: '', 
                    content: '', 
                    answer: '', 
                    contentImages: [], 
                    answerImages: [],
                    tags: { isLogical: false, hasDeath: false, isHuman: true }
                });
                
                // é¢˜ç›®é¢„è§ˆç›¸å…³çš„æ ‡ç­¾
                const previewTags = ref({ isLogical: false, hasDeath: false, isHuman: true });
                
                // å›¾ç‰‡æŸ¥çœ‹ç›¸å…³
                const showImageModal = ref(false);
                const currentImageSrc = ref('');
                const currentImageList = ref([]);
                const currentImageIndex = ref(0);
                const imageScale = ref(1); // å›¾ç‰‡ç¼©æ”¾æ¯”ä¾‹
                const imageTranslate = ref({ x: 0, y: 0 }); // å›¾ç‰‡ä½ç§»
                
                // æ£€æµ‹æ˜¯å¦ä¸º SVG å›¾ç‰‡
                const isSvgImage = computed(() => {
                    return currentImageSrc.value.toLowerCase().includes('.svg') || 
                           currentImageSrc.value.toLowerCase().includes('data:image/svg');
                });
                
                // SVG å›¾ç‰‡çš„å›ºå®šå®½åº¦ï¼ˆå“åº”å¼ï¼‰
                const svgWidth = computed(() => {
                    if (!isSvgImage.value) return null;
                    // ç§»åŠ¨ç«¯ä½¿ç”¨ 90vwï¼Œå®½å±ä½¿ç”¨ 60vw
                    return window.innerWidth < 768 ? '100vw' : '75vw';
                });
                const persistRole = (hostFlag) => {
                    localStorage.setItem('turtle_role', hostFlag ? 'host' : 'player');
                };
                
                // é¢˜ç›®é¢„è§ˆç›¸å…³
                const showPreviewModal = ref(false);
                const previewPuzzle = ref(null);
                
                // ç”³è¯·ä¸»æŒå†·å´æ—¶é—´
                const requestHostCooldown = ref(false);
                
                // æœåŠ¡å™¨è¿æ¥çŠ¶æ€
                const serverConnected = ref(true);
                
                // æ¢å¤å†³å®šç›¸å…³
                const showRecoveryDecision = ref(false);
                const showRecoveryWaiting = ref(false);
                
                // æ¸¸æˆé™åˆ¶ç›¸å…³
                const gameLimits = ref({ maxQuestionsPerPlayer: null, maxTotalQuestions: null });
                const settingsForm = ref({ maxQuestionsPerPlayer: '', maxTotalQuestions: '' });
                
                // å‰©ä½™æ¬¡æ•°ç›¸å…³ (ä»æœåŠ¡å™¨å®æ—¶æ›´æ–°)
                const remainingCounts = ref({
                    personalRemaining: null,
                    personalUsed: 0,
                    personalTotal: null,
                    publicRemaining: null,
                    publicUsed: 0,
                    publicTotal: null,
                    totalUsed: 0,
                    canAsk: true
                });
                
                // æ¸¸æˆæ—¶é•¿ç›¸å…³
                const gameStartTime = ref(null);
                const gameEndTime = ref(null);
                const gameDuration = ref('');
                let durationTimer = null;

                const updateDuration = () => {
                    if (!gameStartTime.value) {
                        gameDuration.value = '';
                        return;
                    }
                    
                    // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œä½¿ç”¨ç»“æŸæ—¶é—´è®¡ç®—
                    const endTime = gameEndTime.value || Date.now();
                    const diff = Math.floor((endTime - gameStartTime.value) / 1000);
                    const hours = Math.floor(diff / 3600).toString().padStart(2, '0');
                    const minutes = Math.floor((diff % 3600) / 60).toString().padStart(2, '0');
                    const seconds = (diff % 60).toString().padStart(2, '0');
                    gameDuration.value = `${hours}:${minutes}:${seconds}`;
                };

                const startDurationTimer = () => {
                    if (durationTimer) clearInterval(durationTimer);
                    updateDuration();
                    durationTimer = setInterval(updateDuration, 1000);
                };

                const stopDurationTimer = () => {
                    if (durationTimer) {
                        clearInterval(durationTimer);
                        durationTimer = null;
                    }
                    // ä¿ç•™æœ€åçš„æ—¶é•¿æ˜¾ç¤ºï¼Œä¸æ¸…ç©º
                };
                
                const canAskQuestion = computed(() => {
                    if (!currentPuzzle.value || gameOver.value) return false;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return false;
                    }

                    // ä½¿ç”¨åç«¯æä¾›çš„canAskçŠ¶æ€
                    return remainingCounts.value?.canAsk ?? true;
                });
                
                const questionPlaceholder = computed(() => {
                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å·²ç»“æŸ
                    if (gameOver.value) {
                        return 'æœ¬å±€æ¸¸æˆå·²ç»“æŸ';
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return 'è¯·ç­‰å¾…ä¸»æŒäººå¤„ç†æ‚¨çš„ä¸Šä¸€æ¡çŒœæµ‹...';
                    }

                    if (!canAskQuestion.value) {
                        const counts = remainingCounts.value;
                        const limits = gameLimits.value;
                        
                        // ä¸ªäººé…é¢ç”¨å®Œä¸”æœ‰äººè¿˜æœ‰é…é¢
                        if (limits.maxQuestionsPerPlayer && counts?.personalRemaining === 0) {
                            // å¦‚æœå…¬å…±æ± è¿˜æœ‰æˆ–è€…æ²¡æœ‰å…¬å…±é™åˆ¶ï¼Œè¯´æ˜åœ¨ç­‰å…¶ä»–äºº
                            if (!limits.maxTotalQuestions || (counts?.publicRemaining ?? 0) > 0) {
                                return 'è¯·ç­‰å¾…å…¶ä»–ç©å®¶ä½¿ç”¨å®Œä¸ªäººæ¬¡æ•°';
                            }
                        }
                        
                        // å…¬å…±æ± ç”¨å®Œ
                        if (limits.maxTotalQuestions && (counts?.publicRemaining ?? 0) === 0) {
                            return 'å…¨å‘˜å…¬å…±æ¬¡æ•°å·²ç”¨å°½';
                        }
                        
                        return 'çŒœæµ‹æ¬¡æ•°å·²ç”¨å°½';
                    }
                    return '';
                });
                
                // æ˜¯å¦éœ€è¦é†’ç›®æç¤ºï¼ˆå‰©ä½™5/10/15ç­‰5çš„å€æ•°ï¼‰
                const shouldHighlightRemaining = computed(() => {
                    const counts = remainingCounts.value;
                    if (!counts) return false;
                    
                    let total = 0;
                    if (counts.personalRemaining !== null) total += counts.personalRemaining;
                    if (counts.publicRemaining !== null) total += counts.publicRemaining;
                    
                    if (total === 0) return false;
                    return total % 5 === 0 && total <= 15;
                });

                // ç§»åŠ¨ç«¯UIçŠ¶æ€
                const isPuzzleExpanded = ref(false);
                const isAnswerExpanded = ref(true); // æ±¤åº•å±•å¼€çŠ¶æ€ï¼ˆé»˜è®¤å±•å¼€ï¼‰
                const autoResize = (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = e.target.scrollHeight + 'px';
                };

                // åˆ‡æ¢å±•å¼€çŠ¶æ€æ—¶ä¿æŒæ»šåŠ¨ä½ç½®
                const togglePuzzleExpanded = () => {
                    const scrollY = window.scrollY;
                    isPuzzleExpanded.value = !isPuzzleExpanded.value;
                    Vue.nextTick(() => {
                        window.scrollTo(0, scrollY);
                    });
                };

                const toggleAnswerExpanded = () => {
                    const scrollY = window.scrollY;
                    isAnswerExpanded.value = !isAnswerExpanded.value;
                    Vue.nextTick(() => {
                        window.scrollTo(0, scrollY);
                    });
                };

                // åˆå§‹åŒ–Socketè¿æ¥å’Œç›‘å¬å™¨
                const initSocket = () => {
                    if (socket) return; // é˜²æ­¢é‡å¤è¿æ¥
                    socket = io();

                    socket.on('connect', () => {
                        serverConnected.value = true;
                        const storedUserId = localStorage.getItem('turtle_uid');
                        const sessionId = localStorage.getItem('turtle_session_id');
                        const roleHint = localStorage.getItem('turtle_role');

                        if (pendingJoinPayload) {
                            socket.emit('join', pendingJoinPayload);
                            pendingJoinPayload = null;
                            return;
                        }

                        // å¦‚æœå·²ç»åŠ å…¥è¿‡æ¸¸æˆï¼ˆæ–­çº¿é‡è¿çš„æƒ…å†µï¼‰ï¼Œè‡ªåŠ¨é‡æ–°å‘é€join
                        if (joined.value) {
                            socket.emit('join', { 
                                nickname: nickname.value, 
                                userId: storedUserId,
                                sessionId,
                                roleHint
                            });
                        }
                    });

                    socket.on('init_state', (state) => {
                        // æ£€æŸ¥æœåŠ¡å™¨ä¼šè¯ID
                        const storedSessionId = localStorage.getItem('turtle_session_id');
                        
                        // æ¢å¤æ¨¡å¼ï¼šæœåŠ¡å™¨æœ‰ä¿å­˜çš„æ¸¸æˆçŠ¶æ€
                        if (state.recoveryMode) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æœåŠ¡å™¨é‡å¯åçš„æƒ…å†µ
                            if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                                // æœåŠ¡å™¨é‡å¯äº†ï¼Œä½†æœ‰å¯æ¢å¤çš„æ¸¸æˆ
                                localStorage.setItem('turtle_session_id', state.serverSessionId);
                                
                                // å…ˆæç¤ºæœåŠ¡å™¨é‡å¯
                                alert('æœåŠ¡å™¨å·²é‡å¯');
                                
                                // ç„¶åæ˜¾ç¤ºæ¢å¤å†³å®šå¼¹çª—
                                if (state.waitingForRecoveryDecision) {
                                    if (state.isFirstReconnector) {
                                        showRecoveryDecision.value = true;
                                    } else {
                                        showRecoveryWaiting.value = true;
                                    }
                                }
                                
                                // æ›´æ–°çŠ¶æ€ä½†ä¸åˆ·æ–°é¡µé¢
                                myId.value = state.myId;
                                if (state.userId) {
                                    localStorage.setItem('turtle_uid', state.userId);
                                    localStorage.setItem('turtle_nickname', nickname.value);
                                }
                                
                                players.value = state.players;
                                const me = state.players.find(p => p.id === state.myId);
                                isHost.value = me?.isHost || false;
                                persistRole(isHost.value);
                                hasHost.value = state.players.some(p => p.isHost);
                                
                                currentPuzzle.value = state.currentPuzzle;
                                history.value = state.history;
                                puzzleList.value = state.puzzles;
                                if (state.limits) {
                                    gameLimits.value = state.limits;
                                }
                                if (state.startTime) {
                                    gameStartTime.value = state.startTime;
                                    startDurationTimer();
                                }
                                scrollToBottom();
                                return;
                            }
                            
                            // ä¸æ¸…é™¤èº«ä»½ä¿¡æ¯ï¼Œç›´æ¥æ¢å¤
                            console.log('Recovery mode: restoring previous game state');
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¦‚æœåœ¨ç­‰å¾…æ¢å¤å†³å®š
                            if (state.waitingForRecoveryDecision) {
                                if (state.isFirstReconnector) {
                                    // ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶ï¼Œæ˜¾ç¤ºå†³å®šå¼¹çª—
                                    showRecoveryDecision.value = true;
                                } else {
                                    // å…¶ä»–ç©å®¶ï¼Œæ˜¾ç¤ºç­‰å¾…å¼¹çª—
                                    showRecoveryWaiting.value = true;
                                }
                            }
                        }
                        // åªæœ‰å½“æœ¬åœ°å­˜æœ‰æ—§çš„sessionIdï¼Œä¸”ä¸å½“å‰æœåŠ¡å™¨ä¸ä¸€è‡´æ—¶ï¼Œæ‰è§†ä¸ºé‡å¯
                        else if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                            // æœåŠ¡å™¨å·²é‡å¯ï¼Œæ¸…é™¤æ—§çš„èº«ä»½ä¿¡æ¯
                            localStorage.removeItem('turtle_uid');
                            localStorage.removeItem('turtle_role');
                            // localStorage.removeItem('turtle_nickname'); // ä¿ç•™æ˜µç§°
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¼ºåˆ¶åˆ·æ–°é¡µé¢ä»¥é‡æ–°ç™»å½•
                            alert('æœåŠ¡å™¨å·²é‡å¯ï¼Œè¯·é‡æ–°åŠ å…¥æ¸¸æˆ');
                            location.reload();
                            return;
                        }

                        // å¦‚æœæ˜¯é¦–æ¬¡è¿›å…¥ï¼ˆæ— æœ¬åœ°sessionIdï¼‰ï¼Œä¿å­˜å½“å‰çš„
                        if (!storedSessionId && state.serverSessionId) {
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                        }

                        myId.value = state.myId;
                        // ä¿å­˜èº«ä»½ä¿¡æ¯
                        if (state.userId) {
                            localStorage.setItem('turtle_uid', state.userId);
                            localStorage.setItem('turtle_nickname', nickname.value);
                        }
                        
                        players.value = state.players;
                        const me = state.players.find(p => p.id === state.myId);
                        isHost.value = me?.isHost || false;
                        persistRole(isHost.value);
                        hasHost.value = state.players.some(p => p.isHost);
                        
                        currentPuzzle.value = state.currentPuzzle;
                        history.value = state.history;
                        puzzleList.value = state.puzzles;
                        gameOver.value = state.gameOver || false;
                        if (state.limits) {
                            gameLimits.value = state.limits;
                        }
                        // ä¿å­˜å‰©ä½™æ¬¡æ•°æ•°æ®
                        if (state.remainingCounts) {
                            remainingCounts.value = state.remainingCounts;
                        }
                        if (state.startTime) {
                            gameStartTime.value = state.startTime;
                            if (state.endTime) {
                                // æ¸¸æˆå·²ç»“æŸï¼Œè®¾ç½®ç»“æŸæ—¶é—´å¹¶åœæ­¢è®¡æ—¶å™¨
                                gameEndTime.value = state.endTime;
                                updateDuration();
                                stopDurationTimer();
                            } else {
                                // æ¸¸æˆè¿›è¡Œä¸­ï¼Œå¯åŠ¨è®¡æ—¶å™¨
                                gameEndTime.value = null;
                                startDurationTimer();
                            }
                        } else {
                            stopDurationTimer();
                        }
                        scrollToBottom();
                    });

                    socket.on('player_update', (list) => {
                        players.value = list;
                        const me = list.find(p => p.id === myId.value);
                        if (me) {
                            isHost.value = me.isHost;
                            persistRole(me.isHost);
                        }
                        hasHost.value = list.some(p => p.isHost);
                    });

                    socket.on('host_data', (puzzles) => {
                        puzzleList.value = puzzles;
                    });

                    socket.on('new_puzzle', (data) => {
                        // å…¼å®¹æ—§æ ¼å¼
                        if (data.title) {
                            currentPuzzle.value = data;
                        } else {
                            currentPuzzle.value = data.puzzle;
                        }
                        
                        if (data.limits) {
                            gameLimits.value = data.limits;
                        } else {
                            gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        }
                        
                        if (data.startTime) {
                            gameStartTime.value = data.startTime;
                            startDurationTimer();
                        }

                        history.value = [];
                        gameOver.value = false;
                    });

                    socket.on('puzzle_reveal', (fullPuzzle) => {
                        currentPuzzle.value = fullPuzzle;
                    });
                    
                    socket.on('puzzle_updated', (data) => {
                        console.log('[PUZZLE_UPDATED] Received update:', data);
                        
                        // æ›´æ–°é¢˜ç›®ä¿¡æ¯ï¼ˆæ™®é€šç©å®¶åªèƒ½çœ‹åˆ°é¢˜é¢ï¼‰
                        if (currentPuzzle.value && data.puzzle) {
                            // ä½¿ç”¨å¯¹è±¡å±•å¼€ç¡®ä¿è§¦å‘å“åº”å¼æ›´æ–°
                            currentPuzzle.value = {
                                ...currentPuzzle.value,
                                title: data.puzzle.title,
                                content: data.puzzle.content,
                                contentImages: data.puzzle.contentImages || []
                            };
                            console.log('[PUZZLE_UPDATED] Updated currentPuzzle:', currentPuzzle.value);
                        }
                        
                        // æ›´æ–°æ¬¡æ•°é™åˆ¶
                        if (data.limits) {
                            gameLimits.value = { ...data.limits };
                            console.log('[PUZZLE_UPDATED] Updated limits:', gameLimits.value);
                        }
                    });

                    socket.on('new_question', (q) => {
                        history.value.push(q);
                        scrollToBottom();
                    });

                    socket.on('question_answered', (updatedQ) => {
                        const idx = history.value.findIndex(h => h.id === updatedQ.id);
                        if (idx !== -1) {
                            history.value[idx] = updatedQ;
                        }
                    });

                    socket.on('game_over', (data) => {
                        gameOver.value = true;
                        if (data.puzzle) {
                            // æ›´æ–°å½“å‰é¢˜ç›®ä¸ºå®Œæ•´çš„é¢˜ç›®ä¿¡æ¯ï¼ˆåŒ…å«æ±¤åº•ï¼‰
                            currentPuzzle.value = data.puzzle;
                        }
                        if (data.endTime) {
                            // è®¾ç½®ç»“æŸæ—¶é—´å¹¶åœæ­¢è®¡æ—¶å™¨
                            gameEndTime.value = data.endTime;
                            updateDuration();
                            stopDurationTimer();
                        }
                    });

                    socket.on('return_to_lobby', () => {
                        currentPuzzle.value = null;
                        history.value = [];
                        gameOver.value = false;
                        gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        gameStartTime.value = null;
                        gameEndTime.value = null;
                        stopDurationTimer();
                        gameDuration.value = ''; // è¿”å›å¤§å…æ—¶æ‰æ¸…ç©ºæ—¶é•¿æ˜¾ç¤º
                    });

                    socket.on('error_message', (data) => {
                        alert(data.message);
                    });

                    socket.on('host_transfer_request', (data) => {
                        if (confirm(`ç©å®¶ ${data.requesterName} æƒ³è¦æˆä¸ºä¸»æŒäººï¼Œæ˜¯å¦åŒæ„è½¬è®©ä¸»æŒæƒï¼Ÿ`)) {
                            socket.emit('approve_host_transfer', data.requesterId);
                        } else {
                            socket.emit('reject_host_transfer', data.requesterId);
                        }
                    });

                    socket.on('host_transfer_rejected', () => {
                        alert('ä¸»æŒäººæ‹’ç»äº†ä½ çš„ç”³è¯·');
                    });

                    socket.on('disconnect', () => {
                        serverConnected.value = false;
                        console.log('Server connection lost');
                    });

                    socket.on('reconnect', () => {
                        serverConnected.value = true;
                        console.log('Server reconnected');
                    });

                    socket.on('recovery_decision_made', (data) => {
                        showRecoveryDecision.value = false;
                        showRecoveryWaiting.value = false;
                        
                        if (!data.recover) {
                            // é€‰æ‹©é‡å¼€æ–°å±€ï¼Œåˆ·æ–°é¡µé¢
                            location.reload();
                        }
                    });

                    // ç›‘å¬å‰©ä½™æ¬¡æ•°æ›´æ–°
                    socket.on('remaining_counts_update', (counts) => {
                        console.log('[å‰©ä½™æ¬¡æ•°æ›´æ–°]', counts);
                        remainingCounts.value = counts;
                    });
                };

                const joinGame = () => {
                    if (!nickname.value.trim()) return;
                    
                    // ç¡®ä¿è¿æ¥å·²å»ºç«‹
                    initSocket();

                    // å°è¯•è·å–æœ¬åœ°å­˜å‚¨çš„ userId
                    const storedUserId = localStorage.getItem('turtle_uid');
                    const sessionId = localStorage.getItem('turtle_session_id');
                    const roleHint = localStorage.getItem('turtle_role');
                    const payload = {
                        nickname: nickname.value,
                        userId: storedUserId,
                        sessionId,
                        roleHint
                    };

                    if (socket?.connected) {
                        socket.emit('join', payload);
                    } else {
                        pendingJoinPayload = payload;
                    }
                    joined.value = true;
                };

                const requestHost = () => {
                    if (requestHostCooldown.value) {
                        alert('è¯·ç¨åå†è¯•ï¼Œå†·å´æ—¶é—´æœªç»“æŸ');
                        return;
                    }
                    
                    socket.emit('request_host');
                    requestHostCooldown.value = true;
                    
                    setTimeout(() => {
                        requestHostCooldown.value = false;
                    }, 8000);
                };

                const selectPuzzle = (id) => {
                    socket.emit('select_puzzle', id);
                };
                
                const submitCustomPuzzle = () => {
                    if (!customForm.value.title) {
                        alert('è¯·å¡«å†™æ ‡é¢˜');
                        return;
                    }
                    
                    // éªŒè¯æ±¤é¢ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasContentText = customForm.value.content && customForm.value.content.trim();
                    const hasContentImages = customForm.value.contentImages && customForm.value.contentImages.length > 0;
                    if (!hasContentText && !hasContentImages) {
                        alert('æ±¤é¢å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    // éªŒè¯æ±¤åº•ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasAnswerText = customForm.value.answer && customForm.value.answer.trim();
                    const hasAnswerImages = customForm.value.answerImages && customForm.value.answerImages.length > 0;
                    if (!hasAnswerText && !hasAnswerImages) {
                        alert('æ±¤åº•å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    if (!confirm('ç¡®å®šè¦ä½¿ç”¨è¿™ä¸ªè‡ªå®šä¹‰é¢˜ç›®å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                        return;
                    }

                    // æ·±æ‹·è´ä»¥é˜²æ­¢å¼•ç”¨é—®é¢˜
                    const payload = JSON.parse(JSON.stringify(customForm.value));
                    // æ·»åŠ é™åˆ¶è®¾ç½®
                    payload.maxQuestionsPerPlayer = settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null;
                    payload.maxTotalQuestions = settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null;
                    
                    socket.emit('create_custom_puzzle', payload);
                    
                    showCustomModal.value = false;
                    customForm.value = { 
                        title: '', 
                        content: '', 
                        answer: '', 
                        contentImages: [], 
                        answerImages: [],
                        tags: { isLogical: false, hasDeath: false, isHuman: true }
                    };
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                };

                const sendQuestion = () => {
                    socket.emit('ask_question');
                };

                const answer = (questionId, type) => {
                    const questionText = questionInputs.value[questionId];
                    if (!questionText || !questionText.trim()) {
                        alert('è¯·å…ˆå¡«å†™ç©å®¶æƒ³é—®çš„å…·ä½“é—®é¢˜');
                        return;
                    }
                    const customText = customAnswers.value[questionId];
                    socket.emit('answer_question', { 
                        questionId,
                        questionText: questionText.trim(),
                        answerType: type, 
                        customText 
                    });
                    // æ¸…ç†è¾“å…¥æ¡†
                    delete customAnswers.value[questionId];
                    delete questionInputs.value[questionId];
                };

                const revealAnswer = () => {
                    if(confirm('ç¡®å®šè¦æ­æ™“æ±¤åº•å¹¶ç»“æŸæœ¬å±€å—ï¼Ÿ')) {
                        socket.emit('reveal_answer');
                    }
                };

                const returnToLobby = () => {
                    if(confirm('ç¡®å®šè¦è¿”å›å¤§å…é€‰æ–°é¢˜å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                        socket.emit('return_to_lobby');
                    }
                };

                const scrollToBottom = () => {
                    nextTick(() => {
                        if (historyBox.value) {
                            historyBox.value.scrollTop = historyBox.value.scrollHeight;
                        }
                    });
                };

                // Socket Listeners
                onMounted(() => {
                    // è‡ªåŠ¨ç™»å½•æ£€æŸ¥
                    const storedNickname = localStorage.getItem('turtle_nickname');
                    const storedUserId = localStorage.getItem('turtle_uid');
                    
                    if (storedNickname) {
                        nickname.value = storedNickname;
                    }

                    if (storedNickname && storedUserId) {
                        joinGame();
                    }
                    
                    // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    
                    // é¡µé¢å¸è½½æ—¶æ–­å¼€è¿æ¥ï¼ˆä»…åœ¨å¤§å…æ—¶æ¸…ç†ï¼‰
                    window.addEventListener('beforeunload', () => {
                        // å¦‚æœä¸åœ¨æ¸¸æˆä¸­ï¼Œä¸»åŠ¨æ–­å¼€è¿æ¥
                        if (!currentPuzzle.value && socket && socket.connected) {
                            socket.disconnect();
                        }
                    });
                });

                const claimHost = () => {
                    socket.emit('claim_host');
                };

                const resignHost = () => {
                    if (confirm('ç¡®å®šè¦é€€å‡ºä¸»æŒäººè§’è‰²å—ï¼Ÿ')) {
                        socket.emit('resign_host');
                    }
                };

                const previewPuzzleDetails = (puzzle) => {
                    previewPuzzle.value = puzzle;
                    showPreviewModal.value = true;
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                    // åˆå§‹åŒ–é¢„è§ˆæ ‡ç­¾ï¼ˆå¦‚æœé¢˜ç›®æœ‰æ ‡ç­¾åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                    previewTags.value = puzzle.tags ? { ...puzzle.tags } : { isLogical: false, hasDeath: false, isHuman: true };
                };

                const confirmStartPuzzle = () => {
                    if (!previewPuzzle.value) return;
                    
                    const onlinePlayers = players.value.filter(p => p.isOnline);
                    if (onlinePlayers.length < 2) {
                        alert('è‡³å°‘éœ€è¦2åç©å®¶æ‰èƒ½å¼€å§‹æ¸¸æˆï¼ˆåŒ…æ‹¬ä¸»æŒäººï¼‰');
                        return;
                    }

                    const options = {
                        id: previewPuzzle.value.id,
                        maxQuestionsPerPlayer: settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null,
                        maxTotalQuestions: settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null,
                        tags: previewTags.value  // æ·»åŠ æ ‡ç­¾åˆ°é€‰é¡¹ä¸­
                    };

                    socket.emit('select_puzzle', options);
                    showPreviewModal.value = false;
                    previewPuzzle.value = null;
                };

                const recoverGame = () => {
                    socket.emit('recover_game');
                    showRecoveryDecision.value = false;
                };

                const startNewGame = () => {
                    if (confirm('ç¡®å®šè¦æ”¾å¼ƒä¸Šä¸€å±€æ¸¸æˆï¼Œå¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿ')) {
                        socket.emit('start_new_game');
                        showRecoveryDecision.value = false;
                    }
                };

                const kickPlayer = (playerId) => {
                    if (confirm('ç¡®å®šè¦è¸¢å‡ºè¯¥ç¦»çº¿ç©å®¶å—ï¼Ÿ')) {
                        socket.emit('kick_player', playerId);
                    }
                };
                
                const openEditModal = () => {
                    if (!currentPuzzle.value) return;
                    // å¡«å……å½“å‰é¢˜ç›®æ•°æ®
                    editForm.value = {
                        title: currentPuzzle.value.title || '',
                        content: currentPuzzle.value.content || '',
                        answer: currentPuzzle.value.answer || '',
                        contentImages: currentPuzzle.value.contentImages ? [...currentPuzzle.value.contentImages] : [],
                        answerImages: currentPuzzle.value.answerImages ? [...currentPuzzle.value.answerImages] : [],
                        maxQuestionsPerPlayer: gameLimits.value.maxQuestionsPerPlayer || '',
                        maxTotalQuestions: gameLimits.value.maxTotalQuestions || '',
                        tags: currentPuzzle.value.tags ? { ...currentPuzzle.value.tags } : { isLogical: false, hasDeath: false, isHuman: true }
                    };
                    showEditModal.value = true;
                };
                
                const submitEditPuzzle = () => {
                    if (!editForm.value.title) {
                        alert('è¯·å¡«å†™æ ‡é¢˜');
                        return;
                    }
                    
                    // éªŒè¯æ±¤é¢ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasContentText = editForm.value.content && editForm.value.content.trim();
                    const hasContentImages = editForm.value.contentImages && editForm.value.contentImages.length > 0;
                    if (!hasContentText && !hasContentImages) {
                        alert('æ±¤é¢å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    // éªŒè¯æ±¤åº•ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasAnswerText = editForm.value.answer && editForm.value.answer.trim();
                    const hasAnswerImages = editForm.value.answerImages && editForm.value.answerImages.length > 0;
                    if (!hasAnswerText && !hasAnswerImages) {
                        alert('æ±¤åº•å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    if (!confirm('ç¡®å®šè¦ä¿å­˜ä¿®æ”¹å—ï¼Ÿ')) {
                        return;
                    }

                    const payload = JSON.parse(JSON.stringify(editForm.value));
                    payload.maxQuestionsPerPlayer = editForm.value.maxQuestionsPerPlayer ? parseInt(editForm.value.maxQuestionsPerPlayer) : null;
                    payload.maxTotalQuestions = editForm.value.maxTotalQuestions ? parseInt(editForm.value.maxTotalQuestions) : null;
                    
                    socket.emit('update_puzzle', payload);
                    
                    showEditModal.value = false;
                };

                const handleContentImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!customForm.value.contentImages) {
                                customForm.value.contentImages = [];
                            }
                            customForm.value.contentImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const handleAnswerImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!customForm.value.answerImages) {
                                customForm.value.answerImages = [];
                            }
                            customForm.value.answerImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const removeContentImage = (index) => {
                    customForm.value.contentImages.splice(index, 1);
                };
                
                const removeAnswerImage = (index) => {
                    customForm.value.answerImages.splice(index, 1);
                };
                
                const handleEditContentImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!editForm.value.contentImages) {
                                editForm.value.contentImages = [];
                            }
                            editForm.value.contentImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const handleEditAnswerImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!editForm.value.answerImages) {
                                editForm.value.answerImages = [];
                            }
                            editForm.value.answerImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const removeEditContentImage = (index) => {
                    editForm.value.contentImages.splice(index, 1);
                };
                
                const removeEditAnswerImage = (index) => {
                    editForm.value.answerImages.splice(index, 1);
                };
                
                const openImageModal = (src, imageList = [], index = 0) => {
                    currentImageSrc.value = src;
                    currentImageList.value = imageList.length > 0 ? imageList : [src];
                    currentImageIndex.value = imageList.length > 0 ? index : 0;
                    showImageModal.value = true;
                };
                
                const closeImageModal = () => {
                    showImageModal.value = false;
                    currentImageSrc.value = '';
                    currentImageList.value = [];
                    currentImageIndex.value = 0;
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                const prevImage = () => {
                    if (currentImageList.value.length <= 1) return;
                    currentImageIndex.value = (currentImageIndex.value - 1 + currentImageList.value.length) % currentImageList.value.length;
                    currentImageSrc.value = currentImageList.value[currentImageIndex.value];
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                const nextImage = () => {
                    if (currentImageList.value.length <= 1) return;
                    currentImageIndex.value = (currentImageIndex.value + 1) % currentImageList.value.length;
                    currentImageSrc.value = currentImageList.value[currentImageIndex.value];
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                // å›¾ç‰‡ç¼©æ”¾å’Œæ‹–åŠ¨åŠŸèƒ½
                const handleDoubleClick = (e) => {
                    e.stopPropagation();
                    if (imageScale.value === 1) {
                        imageScale.value = 2;
                    } else {
                        imageScale.value = 1;
                        imageTranslate.value = { x: 0, y: 0 };
                    }
                };
                
                const handleBackgroundClick = (e) => {
                    // ç‚¹å‡»èƒŒæ™¯åŒºåŸŸæ—¶å…³é—­æ¨¡æ€æ¡†ï¼ˆæœªç¼©æ”¾çŠ¶æ€ï¼‰
                    if (imageScale.value === 1) {
                        closeImageModal();
                    }
                };
                
                const handleWheel = (e) => {
                    if (!showImageModal.value) return;
                    e.preventDefault();
                    
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    let newScale = imageScale.value + delta;
                    newScale = Math.max(1, Math.min(3, newScale)); // é™åˆ¶100%-300%
                    
                    if (newScale === 1) {
                        imageTranslate.value = { x: 0, y: 0 };
                    }
                    imageScale.value = newScale;
                };
                
                // é¼ æ ‡æ‹–åŠ¨
                let isDragging = false;
                let dragStart = { x: 0, y: 0 };
                let translateStart = { x: 0, y: 0 };
                
                const handleMouseDown = (e) => {
                    if (imageScale.value <= 1) return;
                    isDragging = true;
                    dragStart = { x: e.clientX, y: e.clientY };
                    translateStart = { ...imageTranslate.value };
                    e.preventDefault();
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging || imageScale.value <= 1) return;
                    const deltaX = (e.clientX - dragStart.x) / imageScale.value;
                    const deltaY = (e.clientY - dragStart.y) / imageScale.value;
                    imageTranslate.value = {
                        x: translateStart.x + deltaX,
                        y: translateStart.y + deltaY
                    };
                };
                
                const handleMouseUp = () => {
                    isDragging = false;
                };
                
                // è§¦æ‘¸ç¼©æ”¾
                let touchStart = null;
                let initialDistance = 0;
                let initialScale = 1;
                let touchStartTranslate = { x: 0, y: 0 };
                let lastTouchTime = 0;
                
                const handleTouchStart = (e) => {
                    if (e.touches.length === 2) {
                        // åŒæŒ‡ç¼©æ”¾
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        initialScale = imageScale.value;
                        e.preventDefault();
                    } else if (e.touches.length === 1) {
                        // å•æŒ‡æ‹–åŠ¨æˆ–åŒå‡»
                        const now = Date.now();
                        if (now - lastTouchTime < 300) {
                            // åŒå‡»
                            handleDoubleClick(e);
                        }
                        lastTouchTime = now;
                        
                        if (imageScale.value > 1) {
                            touchStart = {
                                x: e.touches[0].clientX,
                                y: e.touches[0].clientY
                            };
                            touchStartTranslate = { ...imageTranslate.value };
                        }
                    }
                };
                
                const handleTouchMove = (e) => {
                    if (e.touches.length === 2) {
                        // åŒæŒ‡ç¼©æ”¾
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const distance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        let newScale = initialScale * (distance / initialDistance);
                        newScale = Math.max(1, Math.min(3, newScale)); // é™åˆ¶100%-300%
                        
                        if (newScale === 1) {
                            imageTranslate.value = { x: 0, y: 0 };
                        }
                        imageScale.value = newScale;
                        e.preventDefault();
                    } else if (e.touches.length === 1 && touchStart && imageScale.value > 1) {
                        // å•æŒ‡æ‹–åŠ¨
                        const deltaX = (e.touches[0].clientX - touchStart.x) / imageScale.value;
                        const deltaY = (e.touches[0].clientY - touchStart.y) / imageScale.value;
                        imageTranslate.value = {
                            x: touchStartTranslate.x + deltaX,
                            y: touchStartTranslate.y + deltaY
                        };
                        e.preventDefault();
                    }
                };
                
                const handleTouchEnd = () => {
                    touchStart = null;
                };

                return {
                    joined, nickname, myId, isHost, players, puzzleList, 
                    currentPuzzle, history, questionText, customAnswers, questionInputs, gameOver,
                    joinGame, requestHost, selectPuzzle, sendQuestion, answer, revealAnswer, returnToLobby,
                    historyBox, showCustomModal, customForm, submitCustomPuzzle, hasHost, claimHost, resignHost,
                    showPreviewModal, previewPuzzle, previewPuzzleDetails, confirmStartPuzzle, requestHostCooldown,
                    serverConnected, showRecoveryDecision, showRecoveryWaiting, recoverGame, startNewGame,
                    isPuzzleExpanded, isAnswerExpanded, autoResize, togglePuzzleExpanded, toggleAnswerExpanded,
                    gameLimits, settingsForm, canAskQuestion, questionPlaceholder,
                    kickPlayer, gameDuration, shouldHighlightRemaining, remainingCounts,
                    handleContentImageUpload, handleAnswerImageUpload, removeContentImage, removeAnswerImage,
                    showEditModal, editForm, openEditModal, submitEditPuzzle,
                    handleEditContentImageUpload, handleEditAnswerImageUpload, removeEditContentImage, removeEditAnswerImage,
                    showImageModal, currentImageSrc, currentImageList, currentImageIndex, openImageModal, closeImageModal, prevImage, nextImage,
                    zoomableImage, imageScale, imageTranslate, isSvgImage, svgWidth,
                    handleDoubleClick, handleBackgroundClick, handleWheel, handleMouseDown, handleTouchStart, handleTouchMove, handleTouchEnd,
                    previewTags
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
