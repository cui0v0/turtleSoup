<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ·é¾Ÿæ±¤ Online</title>
    <script src="./tailwindcss_browser@4.js"></script>
    <script src="./vue.global.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        .chat-bubble { max-width: 80%; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.5s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4 max-w-4xl pb-24 md:pb-4">
        
        <!-- ç™»å½•ç•Œé¢ -->
        <div v-if="!joined" class="flex flex-col items-center justify-center h-screen">
            <h1 class="text-6xl font-bold mb-8 text-emerald-500">ğŸ¢ æµ·é¾Ÿæ±¤</h1>
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
                <label class="block mb-2 text-lg">è¯·è¾“å…¥æ˜µç§°</label>
                <input v-model="nickname" @keyup.enter="joinGame" type="text" class="w-full p-3 rounded bg-gray-700 border border-gray-600 focus:border-emerald-500 focus:outline-none mb-4" placeholder="ä½ çš„åå­—...">
                <button @click="joinGame" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded transition cursor-pointer">è¿›å…¥æˆ¿é—´</button>
            </div>
        </div>

        <!-- æ¸¸æˆä¸»ç•Œé¢ -->
        <div v-else>
            <!-- é¡¶éƒ¨æ  -->
            <header class="flex justify-between items-center mb-6 bg-gray-800 p-4 rounded-lg">
                <div>
                    <h1 class="text-2xl font-bold text-emerald-500">æµ·é¾Ÿæ±¤ Online</h1>
                    <p class="text-sm text-gray-400">å½“å‰èº«ä»½: <span :class="isHost ? 'text-yellow-400 font-bold' : 'text-blue-400'">{{ isHost ? 'ä¸»æŒäºº (Host)' : 'ä¾¦æ¢ (Player)' }}</span></p>
                </div>
                <div class="flex items-center gap-4">
                    <div class="text-right">
                        <p class="text-sm">åœ¨çº¿äººæ•°: {{ players.length }}</p>
                        <p class="text-xs text-gray-500">{{ nickname }}</p>
                    </div>
                    <button v-if="!isHost && !hasHost && !currentPuzzle" @click="claimHost" class="text-xs bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-white font-bold animate-pulse">æˆä¸ºä¸»æŒäºº</button>
                    <button v-if="!isHost && hasHost && !currentPuzzle" @click="requestHost" :disabled="requestHostCooldown" :class="requestHostCooldown ? 'opacity-50 cursor-not-allowed' : ''" class="text-xs bg-emerald-600 hover:bg-emerald-700 px-2 py-1 rounded">ç”³è¯·ä¸»æŒ</button>
                    <button v-if="isHost && !currentPuzzle" @click="resignHost" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white">é€€å‡ºä¸»æŒ</button>
                </div>
            </header>

            <!-- ä¸»æŒäººé€‰æ‹©å¼¹çª— (ä»…å½“æ²¡æœ‰ä¸»æŒäººä¸”è‡ªå·±ä¸æ˜¯ä¸»æŒäººæ—¶æ˜¾ç¤º) -->
            <div v-if="!hasHost && !isHost" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <h2 class="text-3xl font-bold mb-4 text-yellow-400">ğŸ¢ è°æ¥å½“æµ·é¾Ÿï¼Ÿ</h2>
                    <p class="text-gray-300 mb-8">å½“å‰æˆ¿é—´è¿˜æ²¡æœ‰ä¸»æŒäººã€‚<br>ä½ æƒ³æˆä¸ºä¸»æŒäººå‡ºé¢˜å—ï¼Ÿ</p>
                    <div class="flex flex-col gap-4">
                        <button @click="claimHost" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 rounded transition text-lg cursor-pointer">
                            æˆ‘æ¥å½“ä¸»æŒäººï¼
                        </button>
                        <p class="text-sm text-gray-500">æˆ–è€…ç­‰å¾…å…¶ä»–äººæˆä¸ºä¸»æŒäºº...</p>
                    </div>
                </div>
            </div>
            <!-- æ¢å¤æ¸¸æˆå†³å®šå¼¹çª— (ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶) -->
            <div v-if="showRecoveryDecision" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[60]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-lg border border-blue-500 shadow-2xl">
                    <h2 class="text-3xl font-bold mb-4 text-blue-400">ğŸ”„ å‘ç°ä¸Šä¸€åœºæ¸¸æˆè®°å½•</h2>
                    <p class="text-gray-300 mb-6 text-lg">æ£€æµ‹åˆ°æœåŠ¡å™¨é‡å¯å‰æœ‰æœªå®Œæˆçš„æ¸¸æˆå¯¹å±€ï¼Œæ˜¯å¦è¦æ¢å¤ï¼Ÿ</p>
                    <div class="bg-blue-900/30 border border-blue-600 rounded p-4 mb-6">
                        <p class="text-blue-200 text-sm">âœ“ æ¢å¤æ¸¸æˆå°†ä¿ç•™æ‰€æœ‰æ¨ç†å†å²å’Œé¢˜ç›®ä¿¡æ¯</p>
                        <p class="text-blue-200 text-sm mt-2">âœ“ æ‰€æœ‰ç©å®¶å°†æ¢å¤åŸæœ‰çš„æ˜µç§°å’Œè§’è‰²</p>
                    </div>
                    <div class="flex gap-4">
                        <button @click="startNewGame" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 rounded transition cursor-pointer">
                            é‡å¼€æ–°å±€
                        </button>
                        <button @click="recoverGame" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded transition cursor-pointer">
                            æ¢å¤æ¸¸æˆ
                        </button>
                    </div>
                </div>
            </div>

            <!-- ç­‰å¾…æ¢å¤å†³å®šå¼¹çª— (å…¶ä»–ç©å®¶) -->
            <div v-if="showRecoveryWaiting" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[55]">
                <div class="bg-gray-800 p-8 rounded-lg w-full max-w-md border border-yellow-500 shadow-2xl text-center">
                    <div class="mb-6">
                        <svg class="animate-spin h-16 w-16 text-yellow-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h2 class="text-2xl font-bold mb-4 text-yellow-400">â³ ç­‰å¾…å†³å®šä¸­...</h2>
                    <p class="text-gray-300 text-lg">å…¶ä»–ç©å®¶æ­£åœ¨å†³å®šæ˜¯å¦æ¢å¤ä¸Šä¸€åœºæ¸¸æˆ</p>
                    <p class="text-gray-500 text-sm mt-4">è¯·ç¨å€™</p>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                
                <!-- å·¦ä¾§/ä¸Šæ–¹ï¼šé¢˜ç›®åŒºåŸŸ -->
                <div class="md:col-span-2 space-y-6">
                    <!-- é€‰é¢˜åŒºåŸŸ (ä»…ä¸»æŒäººä¸”æ— é¢˜ç›®æ—¶æ˜¾ç¤º) -->
                    <div v-if="isHost && !currentPuzzle" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold text-yellow-400">é€‰æ‹©ä¸€ä¸ªæ±¤é¢</h2>
                            <button @click="showCustomModal = true" class="text-sm bg-emerald-600 hover:bg-emerald-700 px-3 py-1 rounded text-white transition cursor-pointer">+ è‡ªå®šä¹‰</button>
                        </div>
                        <div class="space-y-2 max-h-96 overflow-y-auto">
                            <div v-for="p in puzzleList" :key="p.id" @click="previewPuzzleDetails(p)" 
                                class="p-4 bg-gray-700 hover:bg-gray-600 rounded cursor-pointer transition border-l-4 border-transparent hover:border-yellow-400">
                                <h3 class="font-bold">{{ p.title }}</h3>
                                <p class="text-sm text-gray-400 truncate">{{ p.content }}</p>
                            </div>
                        </div>
                    </div>

                    <!-- é¢˜ç›®é¢„è§ˆæ¨¡æ€æ¡† -->
                    <div v-if="showPreviewModal && previewPuzzle" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-2xl border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto">
                            <h3 class="text-2xl font-bold mb-4 text-yellow-400">{{ previewPuzzle.title }}</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-bold text-emerald-400 mb-2">æ±¤é¢ (é¢˜ç›®)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        <p v-if="previewPuzzle.content">{{ previewPuzzle.content }}</p>
                                        <div v-if="previewPuzzle.contentImages && previewPuzzle.contentImages.length > 0" class="flex flex-col gap-2 mt-2">
                                            <img v-for="(img, index) in previewPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click.stop="openImageModal(img, previewPuzzle.contentImages, index)">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-red-400 mb-2">æ±¤åº• (ç­”æ¡ˆ)</label>
                                    <div class="bg-gray-900 rounded p-4 text-gray-200 border border-gray-700">
                                        <p v-if="previewPuzzle.answer">{{ previewPuzzle.answer }}</p>
                                        <div v-if="previewPuzzle.answerImages && previewPuzzle.answerImages.length > 0" class="flex flex-col gap-2 mt-2">
                                            <img v-for="(img, index) in previewPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click.stop="openImageModal(img, previewPuzzle.answerImages, index)">
                                        </div>
                                    </div>
                                </div>
                                <div class="bg-yellow-900/30 border border-yellow-600 rounded p-3 text-sm text-yellow-200">
                                    <p>ğŸ’¡ æç¤º: ç©å®¶åªèƒ½çœ‹åˆ°æ±¤é¢ï¼Œä¸ä¼šçœ‹åˆ°æ±¤åº•ã€‚è¯·ç¡®è®¤æ­¤é¢˜ç›®åˆé€‚åå†å¼€å§‹æ¸¸æˆã€‚</p>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showPreviewModal = false; previewPuzzle = null;" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="confirmStartPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                            </div>
                        </div>
                    </div>

                    <!-- ç¼–è¾‘é¢˜ç›®æ¨¡æ€æ¡† -->
                    <div v-if="showEditModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-lg border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto">
                            <h3 class="text-xl font-bold mb-4 text-blue-500">ç¼–è¾‘é¢˜ç›®</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ ‡é¢˜</label>
                                    <input v-model="editForm.title" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="ä¾‹å¦‚ï¼šææ€–çš„ç”µæ¢¯">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤é¢ (é¢˜ç›®) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                                    <textarea v-model="editForm.content" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="æè¿°ç©å®¶çœ‹åˆ°çš„æƒ…æ™¯... (å¯é€‰)"></textarea>
                                    <div class="mt-2">
                                        <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                                        <input type="file" @change="handleEditContentImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer">
                                        <div v-if="editForm.contentImages && editForm.contentImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                            <div v-for="(img, index) in editForm.contentImages" :key="index" class="relative group">
                                                <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                                <button @click="removeEditContentImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤åº• (ç­”æ¡ˆ) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                                    <textarea v-model="editForm.answer" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-blue-500 border border-transparent" placeholder="äº‹æƒ…çš„çœŸç›¸æ˜¯... (å¯é€‰)"></textarea>
                                    <div class="mt-2">
                                        <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                                        <input type="file" @change="handleEditAnswerImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer">
                                        <div v-if="editForm.answerImages && editForm.answerImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                            <div v-for="(img, index) in editForm.answerImages" :key="index" class="relative group">
                                                <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                                <button @click="removeEditAnswerImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-blue-400 mb-3 text-sm">æ¬¡æ•°é™åˆ¶</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="editForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-blue-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="editForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-blue-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showEditModal = false" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="submitEditPuzzle" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-bold transition cursor-pointer">ä¿å­˜ä¿®æ”¹</button>
                            </div>
                        </div>
                    </div>

                    <!-- è‡ªå®šä¹‰é¢˜ç›®æ¨¡æ€æ¡† -->
                    <div v-if="showCustomModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-lg border border-gray-700 shadow-2xl max-h-[90vh] overflow-y-auto">
                            <h3 class="text-xl font-bold mb-4 text-emerald-500">è‡ªå®šä¹‰æµ·é¾Ÿæ±¤</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ ‡é¢˜</label>
                                    <input v-model="customForm.title" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="ä¾‹å¦‚ï¼šææ€–çš„ç”µæ¢¯">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤é¢ (é¢˜ç›®) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                                    <textarea v-model="customForm.content" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="æè¿°ç©å®¶çœ‹åˆ°çš„æƒ…æ™¯... (å¯é€‰)"></textarea>
                                    <div class="mt-2">
                                        <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                                        <input type="file" @change="handleContentImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700 file:cursor-pointer">
                                        <div v-if="customForm.contentImages && customForm.contentImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                            <div v-for="(img, index) in customForm.contentImages" :key="index" class="relative group">
                                                <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                                <button @click="removeContentImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">æ±¤åº• (ç­”æ¡ˆ) <span class="text-xs text-gray-500">- æ–‡å­—å’Œå›¾ç‰‡è‡³å°‘æä¾›ä¸€ç§</span></label>
                                    <textarea v-model="customForm.answer" rows="3" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:border-emerald-500 border border-transparent" placeholder="äº‹æƒ…çš„çœŸç›¸æ˜¯... (å¯é€‰)"></textarea>
                                    <div class="mt-2">
                                        <label class="block text-xs text-gray-400 mb-1">å›¾ç‰‡ (å¯æ·»åŠ å¤šå¼ )</label>
                                        <input type="file" @change="handleAnswerImageUpload" accept="image/*" multiple class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700 file:cursor-pointer">
                                        <div v-if="customForm.answerImages && customForm.answerImages.length > 0" class="mt-2 grid grid-cols-3 gap-2">
                                            <div v-for="(img, index) in customForm.answerImages" :key="index" class="relative group">
                                                <img :src="img" class="w-full h-20 object-cover rounded border border-gray-600">
                                                <button @click="removeAnswerImage(index)" class="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white rounded-full w-5 h-5 text-xs opacity-0 group-hover:opacity-100 transition cursor-pointer">Ã—</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- æ¸¸æˆè®¾ç½® -->
                                <div class="bg-gray-700/50 rounded p-4 border border-gray-600">
                                    <h4 class="font-bold text-emerald-400 mb-3 text-sm">æ¸¸æˆè®¾ç½® (å¯é€‰)</h4>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">æ¯äººæé—®ä¸Šé™</label>
                                            <input v-model="settingsForm.maxQuestionsPerPlayer" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-400 mb-1">å…¨å‘˜æé—®æ€»ä¸Šé™</label>
                                            <input v-model="settingsForm.maxTotalQuestions" type="number" min="1" class="w-full bg-gray-900 rounded p-2 text-white text-sm border border-gray-600 focus:border-emerald-500 focus:outline-none" placeholder="æ— é™åˆ¶">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-end gap-3 mt-6">
                                <button @click="showCustomModal = false" class="px-4 py-2 text-gray-400 hover:text-white transition cursor-pointer">å–æ¶ˆ</button>
                                <button @click="submitCustomPuzzle" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold transition cursor-pointer">å¼€å§‹æ¸¸æˆ</button>
                            </div>
                        </div>
                    </div>

                    <!-- é¢˜ç›®æ˜¾ç¤ºåŒºåŸŸ -->
                    <div v-if="currentPuzzle" class="bg-gray-800 p-6 -mx-4 md:mx-0 rounded-none md:rounded-lg shadow-lg border-t-4 border-emerald-500 sticky top-0 z-30 md:static transition-all">
                        <div class="flex justify-between items-start mb-2">
                            <h2 class="text-2xl font-bold truncate pr-2">{{ currentPuzzle.title }}</h2>
                            <div v-if="isHost" class="flex gap-2 shrink-0">
                                <button @click="openEditModal" v-if="!gameOver" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-white cursor-pointer">ç¼–è¾‘</button>
                                <button @click="revealAnswer" v-if="!gameOver" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white cursor-pointer">æ­æ™“</button>
                                <button @click="returnToLobby" class="text-xs bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded text-white cursor-pointer">è¿”å›</button>
                            </div>
                        </div>

                        <!-- ç§»åŠ¨ç«¯è§†å›¾ (å¯æŠ˜å ) -->
                        <div class="md:hidden">
                            <div class="cursor-pointer group" @click="isPuzzleExpanded = !isPuzzleExpanded">
                                <p v-if="currentPuzzle.content" :class="{'line-clamp-1': !isPuzzleExpanded}" class="text-lg leading-relaxed text-gray-200 mb-1 transition-all">{{ currentPuzzle.content }}</p>
                                <div v-if="currentPuzzle.contentImages && currentPuzzle.contentImages.length > 0 && isPuzzleExpanded" class="flex flex-col gap-2 mb-2">
                                    <img v-for="(img, index) in currentPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600" @click.stop="openImageModal(img, currentPuzzle.contentImages, index)">
                                </div>
                                <p v-if="!isPuzzleExpanded" class="text-xs text-gray-500 text-center mt-1 group-hover:text-emerald-400">â–¼ ç‚¹å‡»å±•å¼€</p>
                                <p v-else class="text-xs text-gray-500 text-center mt-2">â–² ç‚¹å‡»æ”¶èµ·</p>
                            </div>
                            
                            <div v-if="(isHost || gameOver) && isPuzzleExpanded" class="mt-2 cursor-pointer" @click="isAnswerExpanded = !isAnswerExpanded">
                                <div class="p-3 bg-gray-900 rounded border border-gray-700 text-base">
                                    <h3 class="font-bold text-red-400 mb-1 flex justify-between items-center">
                                        <span>æ±¤åº•:</span>
                                        <span class="text-xs text-gray-500 font-normal">{{ isAnswerExpanded ? 'â–² ç‚¹å‡»æ”¶èµ·' : 'â–¼ ç‚¹å‡»å±•å¼€' }}</span>
                                    </h3>
                                    <div v-if="isAnswerExpanded">
                                        <p v-if="currentPuzzle.answer" class="text-gray-300 mb-2">{{ currentPuzzle.answer }}</p>
                                        <div v-if="currentPuzzle.answerImages && currentPuzzle.answerImages.length > 0" class="flex flex-col gap-2">
                                            <img v-for="(img, index) in currentPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600" @click.stop="openImageModal(img, currentPuzzle.answerImages, index)">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- PCç«¯è§†å›¾ (æ€»æ˜¯å®Œæ•´æ˜¾ç¤º) -->
                        <div class="hidden md:block">
                            <p v-if="currentPuzzle.content" class="text-lg leading-relaxed text-gray-200 mb-4">{{ currentPuzzle.content }}</p>
                            <div v-if="currentPuzzle.contentImages && currentPuzzle.contentImages.length > 0" class="flex flex-col gap-2 mb-4">
                                <img v-for="(img, index) in currentPuzzle.contentImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click="openImageModal(img, currentPuzzle.contentImages, index)">
                            </div>
                            
                            <div v-if="isHost || gameOver" class="mt-6 p-4 bg-gray-900 rounded border border-gray-700">
                                <h3 class="text-sm font-bold text-red-400 mb-1">æ±¤åº• (Answer):</h3>
                                <p v-if="currentPuzzle.answer" class="text-gray-300 mb-2">{{ currentPuzzle.answer }}</p>
                                <div v-if="currentPuzzle.answerImages && currentPuzzle.answerImages.length > 0" class="flex flex-col gap-2">
                                    <img v-for="(img, index) in currentPuzzle.answerImages" :key="index" :src="img" class="w-full rounded border border-gray-600 cursor-pointer" @click="openImageModal(img, currentPuzzle.answerImages, index)">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ç­‰å¾…é¢˜ç›® -->
                    <div v-if="!currentPuzzle && !isHost" class="bg-gray-800 p-12 rounded-lg text-center text-gray-500">
                        <p class="text-xl">ç­‰å¾…ä¸»æŒäººå‡ºé¢˜...</p>
                    </div>

                    <!-- æé—®å†å² -->
                    <div v-if="currentPuzzle" class="bg-gray-800 p-4 rounded-lg shadow-lg min-h-[400px] flex flex-col">
                        <h3 class="text-lg font-bold mb-4 border-b border-gray-700 pb-2">æ¨ç†è®°å½•</h3>
                        <div class="flex-1 overflow-y-auto space-y-4 pr-2 custom-scrollbar" ref="historyBox">
                            <div v-for="item in history" :key="item.id" :class="{
                                        'bg-green-700/50': item.answerType === 'yes',
                                        'bg-red-700/50': item.answerType === 'no',
                                        'bg-gray-700/50': item.answerType === 'irrelevant',
                                        'bg-blue-700/50': item.answerType === 'custom',
                                        'bg-yellow-600/50': item.status === 'pending'
                                    }" class="bg-gray-700/50 p-3 rounded">
                                <div class="flex justify-between text-sm text-white/70 mb-1">
                                    <span>{{ item.nickname }}</span>
                                    <span v-if="item.status === 'pending'" class="text-yellow-500">ç­‰å¾…å›ç­”...</span>
                                </div>
                                <p class="font-medium text-white mb-2">Q: {{ item.question }}</p>
                                
                                <!-- å›ç­”åŒºåŸŸ -->
                                <div v-if="item.status === 'answered'" class="flex items-center gap-2 mt-2 pl-4 border-l-2 border-emerald-500">
                                    <span class="text-emerald-400 font-bold">A:</span>
                                    <span :class="{
                                        'text-green-400': item.answerType === 'yes',
                                        'text-red-400': item.answerType === 'no',
                                        'text-gray-400': item.answerType === 'irrelevant',
                                        'text-blue-400': item.answerType === 'custom'
                                    }">{{ item.answer }}</span>
                                </div>

                                <!-- ä¸»æŒäººæ“ä½œåŒº -->
                                <div v-if="isHost && item.status === 'pending'" class="mt-2 flex gap-2 flex-wrap flex-col">
                                    <div class="flex justify-between gap-4">
                                        <button @click="answer(item.id, 'yes')" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-base flex-grow cursor-pointer">æ˜¯</button>
                                        <button @click="answer(item.id, 'no')" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-base flex-grow cursor-pointer">ä¸æ˜¯</button>
                                        <button @click="answer(item.id, 'irrelevant')" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-base flex-grow cursor-pointer">ä¸é‡è¦</button>
                                    </div>
                                    <div class="flex justify-between gap-2">
                                        <input v-model="customAnswers[item.id]" placeholder="è‡ªå®šä¹‰å›ç­”" class="bg-gray-900 text-base px-2 py-1 rounded border border-gray-600 w-46 flex-grow-2">
                                        <button @click="answer(item.id, 'custom')" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded text-base flex-grow cursor-pointer">å‘é€</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§/ä¸‹æ–¹ï¼šæé—®è¾“å…¥æ¡† -->
                <div class="md:col-span-1">
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg sticky top-4">
                        <div v-if="!isHost && currentPuzzle" class="hidden md:block mb-6">
                            <h3 class="font-bold mb-2 text-emerald-400 flex justify-between items-center">
                                <span>æé—®</span>
                                <!-- <span v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" :class="[shouldHighlightRemaining ? 'text-yellow-400 font-bold animate-pulse' : 'text-gray-400 font-normal']" class="text-xs">
                                    å‰©ä½™: 
                                    <span v-if="gameLimits.maxQuestionsPerPlayer">{{ Math.max(0, gameLimits.maxQuestionsPerPlayer - myQuestionCount) }} (ä¸ªäºº)</span>
                                    <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions"> + </span>
                                    <span v-if="gameLimits.maxTotalQuestions">{{ Math.max(0, gameLimits.maxTotalQuestions - publicUsedCount) }} (å…¬å…±)</span>
                                </span> -->
                            </h3>
                            <textarea v-model="questionText" :disabled="!canAskQuestion" 
                                class="w-full h-32 bg-gray-700 rounded p-3 text-white focus:outline-none focus:ring-2 focus:ring-emerald-500 disabled:opacity-50 disabled:cursor-not-allowed"
                                :placeholder="questionPlaceholder"></textarea>
                            <button @click="sendQuestion" :disabled="!canAskQuestion || !questionText.trim()"
                                class="w-full mt-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold py-2 rounded transition cursor-pointer">
                                å‘é€æé—®
                            </button>
                        </div>
                        
                        <div>
                            <h3 class="font-bold mb-2 text-gray-400 text-base flex justify-between items-center">
                                <span>åœ¨çº¿ç©å®¶</span>
                                <span v-if="gameDuration" class="text-sm text-emerald-400 font-mono">{{ gameDuration }}</span>
                            </h3>
                            <!-- ä¸»æŒäººæŸ¥çœ‹å‰©ä½™æ¬¡æ•° -->
                            <div v-if="currentPuzzle && (gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions)" class="mb-3 p-2 bg-gray-700/50 rounded border border-gray-600">
                                <p class="text-xs text-gray-400 mb-1">å‰©ä½™æé—®æ¬¡æ•°:</p>
                                <div class="text-sm">
                                    <span v-if="gameLimits.maxTotalQuestions" class="text-emerald-400">
                                        å…¬å…±æ± : <span class="font-bold">{{ Math.max(0, gameLimits.maxTotalQuestions - publicUsedCount) }}</span>/{{ gameLimits.maxTotalQuestions }}
                                    </span>
                                    <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions" class="text-gray-500 mx-1">|</span>
                                    <span v-if="gameLimits.maxQuestionsPerPlayer" class="text-blue-400">
                                        ä¸ªäººä¸Šé™: {{ gameLimits.maxQuestionsPerPlayer }}
                                    </span>
                                </div>
                            </div>
                            <ul class="space-y-1 text-sm">
                                <li v-for="p in players" :key="p.id" class="flex items-center gap-2" :class="{'opacity-50': !p.isOnline}">
                                    <span class="w-2 h-2 rounded-full" :class="[p.isOnline ? (p.isHost ? 'bg-yellow-400' : 'bg-green-400') : 'bg-gray-500']"></span>
                                    <span :class="{'text-yellow-400': p.isHost}">{{ p.nickname }}</span>
                                    <span v-if="!p.isOnline" class="text-xs text-red-400">(ç¦»çº¿)</span>
                                    <span v-if="p.id === myId" class="text-gray-500 text-xs">(æˆ‘)</span>
                                    <button v-if="isHost && !p.isOnline" @click="kickPlayer(p.id)" class="ml-auto text-xs bg-red-900/80 hover:bg-red-700 text-white px-2 py-1 rounded border border-red-700 transition cursor-pointer" title="è¸¢å‡ºè¯¥ç©å®¶">è¸¢å‡º</button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <!-- ç§»åŠ¨ç«¯åº•éƒ¨æé—®æ  -->
        <div v-if="!isHost && currentPuzzle && !gameOver" class="md:hidden fixed bottom-0 left-0 right-0 bg-gray-800 p-3 border-t border-gray-700 z-40 flex flex-col gap-2 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)]">
            <div v-if="gameLimits.maxQuestionsPerPlayer || gameLimits.maxTotalQuestions" :class="[shouldHighlightRemaining ? 'text-yellow-400 font-bold animate-pulse' : 'text-gray-400']" class="text-xs text-right px-1">
                å‰©ä½™: 
                <span v-if="gameLimits.maxQuestionsPerPlayer">{{ Math.max(0, gameLimits.maxQuestionsPerPlayer - myQuestionCount) }} (ä¸ªäºº)</span>
                <span v-if="gameLimits.maxQuestionsPerPlayer && gameLimits.maxTotalQuestions"> + </span>
                <span v-if="gameLimits.maxTotalQuestions">{{ Math.max(0, gameLimits.maxTotalQuestions - publicUsedCount) }} (å…¬å…±)</span>
            </div>
            <div class="flex gap-2 items-end">
                <textarea id="mobile-question-input" v-model="questionText" rows="1" @input="autoResize" :disabled="!canAskQuestion"
                    class="flex-1 bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-emerald-500 resize-none overflow-hidden min-h-[40px] max-h-[120px] text-sm disabled:opacity-50" 
                    :placeholder="questionPlaceholder"></textarea>
                <button @click="sendQuestion" :disabled="!canAskQuestion || !questionText.trim()" 
                    class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white font-bold px-4 py-2 rounded transition h-[40px] flex items-center justify-center text-sm whitespace-nowrap cursor-pointer">
                    å‘é€
                </button>
            </div>
        </div>

        <!-- å›¾ç‰‡æŸ¥çœ‹æ¨¡æ€æ¡† -->
        <div v-if="showImageModal" class="fixed inset-0 bg-black/95 flex items-center justify-center z-[70] select-none" @wheel.prevent="handleWheel">
            <!-- å·¦ä¾§åˆ‡æ¢åŒºåŸŸ -->
            <div v-if="currentImageList.length > 1 && imageScale === 1" @click="prevImage" class="absolute left-0 top-0 bottom-0 w-1/4 cursor-pointer hover:bg-white/5 transition flex items-center justify-start pl-4 z-[75]">
                <span class="text-white text-4xl opacity-50 hover:opacity-100 transition">â€¹</span>
            </div>
            
            <!-- ä¸­é—´å›¾ç‰‡åŒºåŸŸ -->
            <div class="flex-1 flex items-center justify-center" :class="imageScale === 1 ? 'cursor-pointer' : 'cursor-move'" @click="handleImageClick">
                <div class="max-w-[95vw] max-h-[95vh] relative overflow-hidden" @touchstart="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd">
                    <img 
                        ref="zoomableImage"
                        :src="currentImageSrc" 
                        class="max-w-full max-h-[95vh] object-contain transition-transform" 
                        :style="{
                            transform: `scale(${imageScale}) translate(${imageTranslate.x}px, ${imageTranslate.y}px)`,
                            '-webkit-user-drag': 'none',
                            'touch-action': 'none'
                        }"
                        @dblclick="handleDoubleClick"
                        @mousedown="handleMouseDown"
                    >
                    <button @click.stop="closeImageModal" class="absolute top-4 right-4 opacity-45 bg-red-600 hover:bg-red-700 hover:opacity-100 text-white rounded-full w-10 h-10 text-2xl cursor-pointer z-10">Ã—</button>
                    <!-- å›¾ç‰‡è®¡æ•° -->
                    <div v-if="currentImageList.length > 1" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/70 text-white px-4 py-2 rounded-full text-sm pointer-events-none">
                        {{ currentImageIndex + 1 }} / {{ currentImageList.length }}
                    </div>
                    <!-- ç¼©æ”¾æç¤º -->
                    <div v-if="imageScale > 1" class="absolute top-4 left-4 bg-black/70 text-white px-3 py-1 rounded-full text-xs pointer-events-none">
                        {{ Math.round(imageScale * 100) }}%
                    </div>
                </div>
            </div>
            
            <!-- å³ä¾§åˆ‡æ¢åŒºåŸŸ -->
            <div v-if="currentImageList.length > 1 && imageScale === 1" @click="nextImage" class="absolute right-0 top-0 bottom-0 w-1/4 cursor-pointer hover:bg-white/5 transition flex items-center justify-end pr-4">
                <span class="text-white text-4xl opacity-50 hover:opacity-100 transition">â€º</span>
            </div>
        </div>

        <!-- æœåŠ¡å™¨æ–­å¼€è¿æ¥è­¦å‘Š -->
        <div v-if="!serverConnected && !showRecoveryDecision && !showRecoveryWaiting" class="fixed bottom-0 left-0 right-0 bg-red-600 text-white py-3 px-4 shadow-lg z-50 animate-pulse">
            <div class="container mx-auto flex items-center justify-center gap-3">
                <span class="font-bold text-lg">âš ï¸ æœåŠ¡å™¨è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...</span>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, nextTick } = Vue;
        let socket; // å»¶è¿Ÿåˆå§‹åŒ–
        let pendingJoinPayload = null; // åœ¨è¿æ¥å»ºç«‹å‰ç¼“å­˜ join è¯·æ±‚

        createApp({
            setup() {
                const joined = ref(false);
                const nickname = ref('');
                const myId = ref('');
                const isHost = ref(false);
                const players = ref([]);
                const puzzleList = ref([]);
                const currentPuzzle = ref(null);
                const history = ref([]);
                const questionText = ref('');
                const customAnswers = ref({});
                const gameOver = ref(false);
                const historyBox = ref(null);
                const zoomableImage = ref(null);
                
                // è‡ªå®šä¹‰é¢˜ç›®ç›¸å…³
                const showCustomModal = ref(false);
                const customForm = ref({ title: '', content: '', answer: '', contentImages: [], answerImages: [] });
                const hasHost = ref(false); // æ˜¯å¦å·²æœ‰ä¸»æŒäºº
                
                // ç¼–è¾‘é¢˜ç›®ç›¸å…³
                const showEditModal = ref(false);
                const editForm = ref({ title: '', content: '', answer: '', contentImages: [], answerImages: [] });
                
                // å›¾ç‰‡æŸ¥çœ‹ç›¸å…³
                const showImageModal = ref(false);
                const currentImageSrc = ref('');
                const currentImageList = ref([]);
                const currentImageIndex = ref(0);
                const imageScale = ref(1); // å›¾ç‰‡ç¼©æ”¾æ¯”ä¾‹
                const imageTranslate = ref({ x: 0, y: 0 }); // å›¾ç‰‡ä½ç§»
                const persistRole = (hostFlag) => {
                    localStorage.setItem('turtle_role', hostFlag ? 'host' : 'player');
                };
                
                // é¢˜ç›®é¢„è§ˆç›¸å…³
                const showPreviewModal = ref(false);
                const previewPuzzle = ref(null);
                
                // ç”³è¯·ä¸»æŒå†·å´æ—¶é—´
                const requestHostCooldown = ref(false);
                
                // æœåŠ¡å™¨è¿æ¥çŠ¶æ€
                const serverConnected = ref(true);
                
                // æ¢å¤å†³å®šç›¸å…³
                const showRecoveryDecision = ref(false);
                const showRecoveryWaiting = ref(false);
                
                // æ¸¸æˆé™åˆ¶ç›¸å…³
                const gameLimits = ref({ maxQuestionsPerPlayer: null, maxTotalQuestions: null });
                const settingsForm = ref({ maxQuestionsPerPlayer: '', maxTotalQuestions: '' });
                
                // æ¸¸æˆæ—¶é•¿ç›¸å…³
                const gameStartTime = ref(null);
                const gameDuration = ref('');
                let durationTimer = null;

                const updateDuration = () => {
                    if (!gameStartTime.value) {
                        gameDuration.value = '';
                        return;
                    }
                    const now = Date.now();
                    const diff = Math.floor((now - gameStartTime.value) / 1000);
                    const hours = Math.floor(diff / 3600).toString().padStart(2, '0');
                    const minutes = Math.floor((diff % 3600) / 60).toString().padStart(2, '0');
                    const seconds = (diff % 60).toString().padStart(2, '0');
                    gameDuration.value = `${hours}:${minutes}:${seconds}`;
                };

                const startDurationTimer = () => {
                    if (durationTimer) clearInterval(durationTimer);
                    updateDuration();
                    durationTimer = setInterval(updateDuration, 1000);
                };

                const stopDurationTimer = () => {
                    if (durationTimer) {
                        clearInterval(durationTimer);
                        durationTimer = null;
                    }
                    gameDuration.value = '';
                };
                
                const { computed } = Vue;
                
                const myQuestionCount = computed(() => {
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (!storedUserId) return 0;
                    return history.value.filter(q => q.userId === storedUserId).length;
                });
                
                // è®¡ç®—å…¬å…±æ± å·²ç”¨æ¬¡æ•°
                const publicUsedCount = computed(() => {
                    if (!gameLimits.value.maxQuestionsPerPlayer) return 0;
                    
                    let used = 0;
                    const userCounts = {};
                    
                    history.value.forEach(q => {
                        if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                        if (userCounts[q.userId] >= gameLimits.value.maxQuestionsPerPlayer) {
                            used++;
                        }
                        userCounts[q.userId]++;
                    });
                    
                    return used;
                });
                
                const canAskQuestion = computed(() => {
                    if (!currentPuzzle.value || gameOver.value) return false;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return false;
                    }

                    const limits = gameLimits.value;
                    
                    // æƒ…å†µ1: ä»…æœ‰å…¬å…±æ€»é™åˆ¶ï¼Œæ— ä¸ªäººé™åˆ¶
                    if (!limits.maxQuestionsPerPlayer && limits.maxTotalQuestions) {
                        return history.value.length < limits.maxTotalQuestions;
                    }
                    
                    // æƒ…å†µ2: ä»…æœ‰ä¸ªäººé™åˆ¶ï¼Œæ— å…¬å…±é™åˆ¶
                    if (limits.maxQuestionsPerPlayer && !limits.maxTotalQuestions) {
                        return myQuestionCount.value < limits.maxQuestionsPerPlayer;
                    }
                    
                    // æƒ…å†µ3: åŒæ—¶æœ‰ä¸ªäººé™åˆ¶å’Œå…¬å…±é™åˆ¶
                    if (limits.maxQuestionsPerPlayer && limits.maxTotalQuestions) {
                        // 3.1 ä¸ªäººé…é¢æœªç”¨å®Œ -> å…è®¸
                        if (myQuestionCount.value < limits.maxQuestionsPerPlayer) {
                            return true;
                        }
                        
                        // 3.2 ä¸ªäººé…é¢å·²ç”¨å®Œ -> æ£€æŸ¥æ˜¯å¦æ‰€æœ‰åœ¨çº¿ç©å®¶éƒ½ç”¨å®Œäº†
                        const onlinePlayers = players.value.filter(p => p.isOnline && !p.isHost);
                        // ç»Ÿè®¡æ¯ä¸ªåœ¨çº¿ç©å®¶çš„å·²ç”¨æ¬¡æ•°
                        const userCounts = {};
                        history.value.forEach(q => {
                            if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                            userCounts[q.userId]++;
                        });
                        
                        const someoneHasQuota = onlinePlayers.some(p => {
                            const used = userCounts[p.userId] || 0;
                            return used < limits.maxQuestionsPerPlayer;
                        });
                        
                        if (someoneHasQuota) {
                            return false; // è¿˜æœ‰äººæ²¡ç”¨å®Œï¼Œå¿…é¡»ç­‰å¾…
                        }
                        
                        // 3.3 å¤§å®¶éƒ½ç”¨å®Œäº† -> æ£€æŸ¥å…¬å…±é…é¢
                        return publicUsedCount.value < limits.maxTotalQuestions;
                    }
                    
                    // æƒ…å†µ4: æ— ä»»ä½•é™åˆ¶
                    return true;
                });
                
                const questionPlaceholder = computed(() => {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœªå›ç­”çš„é—®é¢˜
                    const storedUserId = localStorage.getItem('turtle_uid');
                    if (storedUserId) {
                        const hasPending = history.value.some(q => q.userId === storedUserId && q.status === 'pending');
                        if (hasPending) return 'è¯·ç­‰å¾…ä¸»æŒäººå›ç­”æ‚¨æå‡ºçš„ä¸Šä¸€æ¡çŒœæµ‹...';
                    }

                    if (!canAskQuestion.value) {
                        const limits = gameLimits.value;
                        if (limits.maxQuestionsPerPlayer && myQuestionCount.value >= limits.maxQuestionsPerPlayer) {
                            // æ£€æŸ¥æ˜¯å¦æœ‰äººæ²¡ç”¨å®Œ
                            const onlinePlayers = players.value.filter(p => p.isOnline && !p.isHost);
                            const userCounts = {};
                            history.value.forEach(q => {
                                if (!userCounts[q.userId]) userCounts[q.userId] = 0;
                                userCounts[q.userId]++;
                            });
                            const someoneHasQuota = onlinePlayers.some(p => {
                                const used = userCounts[p.userId] || 0;
                                return used < limits.maxQuestionsPerPlayer;
                            });
                            
                            if (someoneHasQuota) return 'è¯·ç­‰å¾…å…¶ä»–ç©å®¶ä½¿ç”¨å®Œä¸ªäººæ¬¡æ•°';
                            if (limits.maxTotalQuestions && publicUsedCount.value >= limits.maxTotalQuestions) return 'å…¨å‘˜å…¬å…±æ¬¡æ•°å·²ç”¨å°½';
                        }
                        return 'æé—®æ¬¡æ•°å·²ç”¨å°½';
                    }
                    return 'è¾“å…¥ä½ çš„é—®é¢˜... (åªèƒ½é—®æ˜¯/å¦çš„é—®é¢˜å“¦)';
                });
                
                // è®¡ç®—å‰©ä½™æ€»æ¬¡æ•°ï¼ˆä¸ªäºº+å…¬å…±ï¼‰
                const remainingTotal = computed(() => {
                    const limits = gameLimits.value;
                    if (!limits.maxQuestionsPerPlayer && !limits.maxTotalQuestions) return null;
                    
                    let total = 0;
                    if (limits.maxQuestionsPerPlayer) {
                        total += Math.max(0, limits.maxQuestionsPerPlayer - myQuestionCount.value);
                    }
                    if (limits.maxTotalQuestions) {
                        total += Math.max(0, limits.maxTotalQuestions - publicUsedCount.value);
                    }
                    return total;
                });
                
                // æ˜¯å¦éœ€è¦é†’ç›®æç¤ºï¼ˆå‰©ä½™5/10/15ç­‰5çš„å€æ•°ï¼‰
                const shouldHighlightRemaining = computed(() => {
                    const remaining = remainingTotal.value;
                    if (remaining === null || remaining === 0) return false;
                    return remaining % 5 === 0 && remaining <= 15;
                });

                // ç§»åŠ¨ç«¯UIçŠ¶æ€
                const isPuzzleExpanded = ref(false);
                const isAnswerExpanded = ref(true); // æ±¤åº•å±•å¼€çŠ¶æ€ï¼ˆé»˜è®¤å±•å¼€ï¼‰
                const autoResize = (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = e.target.scrollHeight + 'px';
                };

                // åˆå§‹åŒ–Socketè¿æ¥å’Œç›‘å¬å™¨
                const initSocket = () => {
                    if (socket) return; // é˜²æ­¢é‡å¤è¿æ¥
                    socket = io();

                    socket.on('connect', () => {
                        serverConnected.value = true;
                        const storedUserId = localStorage.getItem('turtle_uid');
                        const sessionId = localStorage.getItem('turtle_session_id');
                        const roleHint = localStorage.getItem('turtle_role');

                        if (pendingJoinPayload) {
                            socket.emit('join', pendingJoinPayload);
                            pendingJoinPayload = null;
                            return;
                        }

                        // å¦‚æœå·²ç»åŠ å…¥è¿‡æ¸¸æˆï¼ˆæ–­çº¿é‡è¿çš„æƒ…å†µï¼‰ï¼Œè‡ªåŠ¨é‡æ–°å‘é€join
                        if (joined.value) {
                            socket.emit('join', { 
                                nickname: nickname.value, 
                                userId: storedUserId,
                                sessionId,
                                roleHint
                            });
                        }
                    });

                    socket.on('init_state', (state) => {
                        // æ£€æŸ¥æœåŠ¡å™¨ä¼šè¯ID
                        const storedSessionId = localStorage.getItem('turtle_session_id');
                        
                        // æ¢å¤æ¨¡å¼ï¼šæœåŠ¡å™¨æœ‰ä¿å­˜çš„æ¸¸æˆçŠ¶æ€
                        if (state.recoveryMode) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æœåŠ¡å™¨é‡å¯åçš„æƒ…å†µ
                            if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                                // æœåŠ¡å™¨é‡å¯äº†ï¼Œä½†æœ‰å¯æ¢å¤çš„æ¸¸æˆ
                                localStorage.setItem('turtle_session_id', state.serverSessionId);
                                
                                // å…ˆæç¤ºæœåŠ¡å™¨é‡å¯
                                alert('æœåŠ¡å™¨å·²é‡å¯');
                                
                                // ç„¶åæ˜¾ç¤ºæ¢å¤å†³å®šå¼¹çª—
                                if (state.waitingForRecoveryDecision) {
                                    if (state.isFirstReconnector) {
                                        showRecoveryDecision.value = true;
                                    } else {
                                        showRecoveryWaiting.value = true;
                                    }
                                }
                                
                                // æ›´æ–°çŠ¶æ€ä½†ä¸åˆ·æ–°é¡µé¢
                                myId.value = state.myId;
                                if (state.userId) {
                                    localStorage.setItem('turtle_uid', state.userId);
                                    localStorage.setItem('turtle_nickname', nickname.value);
                                }
                                
                                players.value = state.players;
                                const me = state.players.find(p => p.id === state.myId);
                                isHost.value = me?.isHost || false;
                                persistRole(isHost.value);
                                hasHost.value = state.players.some(p => p.isHost);
                                
                                currentPuzzle.value = state.currentPuzzle;
                                history.value = state.history;
                                puzzleList.value = state.puzzles;
                                if (state.limits) {
                                    gameLimits.value = state.limits;
                                }
                                if (state.startTime) {
                                    gameStartTime.value = state.startTime;
                                    startDurationTimer();
                                }
                                scrollToBottom();
                                return;
                            }
                            
                            // ä¸æ¸…é™¤èº«ä»½ä¿¡æ¯ï¼Œç›´æ¥æ¢å¤
                            console.log('Recovery mode: restoring previous game state');
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¦‚æœåœ¨ç­‰å¾…æ¢å¤å†³å®š
                            if (state.waitingForRecoveryDecision) {
                                if (state.isFirstReconnector) {
                                    // ç¬¬ä¸€ä¸ªé‡è¿çš„ç©å®¶ï¼Œæ˜¾ç¤ºå†³å®šå¼¹çª—
                                    showRecoveryDecision.value = true;
                                } else {
                                    // å…¶ä»–ç©å®¶ï¼Œæ˜¾ç¤ºç­‰å¾…å¼¹çª—
                                    showRecoveryWaiting.value = true;
                                }
                            }
                        }
                        // åªæœ‰å½“æœ¬åœ°å­˜æœ‰æ—§çš„sessionIdï¼Œä¸”ä¸å½“å‰æœåŠ¡å™¨ä¸ä¸€è‡´æ—¶ï¼Œæ‰è§†ä¸ºé‡å¯
                        else if (storedSessionId && state.serverSessionId && storedSessionId !== state.serverSessionId) {
                            // æœåŠ¡å™¨å·²é‡å¯ï¼Œæ¸…é™¤æ—§çš„èº«ä»½ä¿¡æ¯
                            localStorage.removeItem('turtle_uid');
                            localStorage.removeItem('turtle_role');
                            // localStorage.removeItem('turtle_nickname'); // ä¿ç•™æ˜µç§°
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                            
                            // å¼ºåˆ¶åˆ·æ–°é¡µé¢ä»¥é‡æ–°ç™»å½•
                            alert('æœåŠ¡å™¨å·²é‡å¯ï¼Œè¯·é‡æ–°åŠ å…¥æ¸¸æˆ');
                            location.reload();
                            return;
                        }

                        // å¦‚æœæ˜¯é¦–æ¬¡è¿›å…¥ï¼ˆæ— æœ¬åœ°sessionIdï¼‰ï¼Œä¿å­˜å½“å‰çš„
                        if (!storedSessionId && state.serverSessionId) {
                            localStorage.setItem('turtle_session_id', state.serverSessionId);
                        }

                        myId.value = state.myId;
                        // ä¿å­˜èº«ä»½ä¿¡æ¯
                        if (state.userId) {
                            localStorage.setItem('turtle_uid', state.userId);
                            localStorage.setItem('turtle_nickname', nickname.value);
                        }
                        
                        players.value = state.players;
                        const me = state.players.find(p => p.id === state.myId);
                        isHost.value = me?.isHost || false;
                        persistRole(isHost.value);
                        hasHost.value = state.players.some(p => p.isHost);
                        
                        currentPuzzle.value = state.currentPuzzle;
                        history.value = state.history;
                        puzzleList.value = state.puzzles;
                        if (state.limits) {
                            gameLimits.value = state.limits;
                        }
                        if (state.startTime) {
                            gameStartTime.value = state.startTime;
                            startDurationTimer();
                        } else {
                            stopDurationTimer();
                        }
                        scrollToBottom();
                    });

                    socket.on('player_update', (list) => {
                        players.value = list;
                        const me = list.find(p => p.id === myId.value);
                        if (me) {
                            isHost.value = me.isHost;
                            persistRole(me.isHost);
                        }
                        hasHost.value = list.some(p => p.isHost);
                    });

                    socket.on('host_data', (puzzles) => {
                        puzzleList.value = puzzles;
                    });

                    socket.on('new_puzzle', (data) => {
                        // å…¼å®¹æ—§æ ¼å¼
                        if (data.title) {
                            currentPuzzle.value = data;
                        } else {
                            currentPuzzle.value = data.puzzle;
                        }
                        
                        if (data.limits) {
                            gameLimits.value = data.limits;
                        } else {
                            gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        }
                        
                        if (data.startTime) {
                            gameStartTime.value = data.startTime;
                            startDurationTimer();
                        }

                        history.value = [];
                        gameOver.value = false;
                    });

                    socket.on('puzzle_reveal', (fullPuzzle) => {
                        currentPuzzle.value = fullPuzzle;
                    });
                    
                    socket.on('puzzle_updated', (data) => {
                        console.log('[PUZZLE_UPDATED] Received update:', data);
                        
                        // æ›´æ–°é¢˜ç›®ä¿¡æ¯ï¼ˆæ™®é€šç©å®¶åªèƒ½çœ‹åˆ°é¢˜é¢ï¼‰
                        if (currentPuzzle.value && data.puzzle) {
                            // ä½¿ç”¨å¯¹è±¡å±•å¼€ç¡®ä¿è§¦å‘å“åº”å¼æ›´æ–°
                            currentPuzzle.value = {
                                ...currentPuzzle.value,
                                title: data.puzzle.title,
                                content: data.puzzle.content,
                                contentImages: data.puzzle.contentImages || []
                            };
                            console.log('[PUZZLE_UPDATED] Updated currentPuzzle:', currentPuzzle.value);
                        }
                        
                        // æ›´æ–°æ¬¡æ•°é™åˆ¶
                        if (data.limits) {
                            gameLimits.value = { ...data.limits };
                            console.log('[PUZZLE_UPDATED] Updated limits:', gameLimits.value);
                        }
                    });

                    socket.on('new_question', (q) => {
                        history.value.push(q);
                        scrollToBottom();
                    });

                    socket.on('question_answered', (updatedQ) => {
                        const idx = history.value.findIndex(h => h.id === updatedQ.id);
                        if (idx !== -1) {
                            history.value[idx] = updatedQ;
                        }
                    });

                    socket.on('game_over', (answer) => {
                        gameOver.value = true;
                        if (currentPuzzle.value) {
                            currentPuzzle.value.answer = answer;
                        }
                    });

                    socket.on('return_to_lobby', () => {
                        currentPuzzle.value = null;
                        history.value = [];
                        gameOver.value = false;
                        gameLimits.value = { maxQuestionsPerPlayer: null, maxTotalQuestions: null };
                        gameStartTime.value = null;
                        stopDurationTimer();
                    });

                    socket.on('error_message', (data) => {
                        alert(data.message);
                    });

                    socket.on('host_transfer_request', (data) => {
                        if (confirm(`ç©å®¶ ${data.requesterName} æƒ³è¦æˆä¸ºä¸»æŒäººï¼Œæ˜¯å¦åŒæ„è½¬è®©ä¸»æŒæƒï¼Ÿ`)) {
                            socket.emit('approve_host_transfer', data.requesterId);
                        } else {
                            socket.emit('reject_host_transfer', data.requesterId);
                        }
                    });

                    socket.on('host_transfer_rejected', () => {
                        alert('ä¸»æŒäººæ‹’ç»äº†ä½ çš„ç”³è¯·');
                    });

                    socket.on('disconnect', () => {
                        serverConnected.value = false;
                        console.log('Server connection lost');
                    });

                    socket.on('reconnect', () => {
                        serverConnected.value = true;
                        console.log('Server reconnected');
                    });

                    socket.on('recovery_decision_made', (data) => {
                        showRecoveryDecision.value = false;
                        showRecoveryWaiting.value = false;
                        
                        if (!data.recover) {
                            // é€‰æ‹©é‡å¼€æ–°å±€ï¼Œåˆ·æ–°é¡µé¢
                            location.reload();
                        }
                    });
                };

                const joinGame = () => {
                    if (!nickname.value.trim()) return;
                    
                    // ç¡®ä¿è¿æ¥å·²å»ºç«‹
                    initSocket();

                    // å°è¯•è·å–æœ¬åœ°å­˜å‚¨çš„ userId
                    const storedUserId = localStorage.getItem('turtle_uid');
                    const sessionId = localStorage.getItem('turtle_session_id');
                    const roleHint = localStorage.getItem('turtle_role');
                    const payload = {
                        nickname: nickname.value,
                        userId: storedUserId,
                        sessionId,
                        roleHint
                    };

                    if (socket?.connected) {
                        socket.emit('join', payload);
                    } else {
                        pendingJoinPayload = payload;
                    }
                    joined.value = true;
                };

                const requestHost = () => {
                    if (requestHostCooldown.value) {
                        alert('è¯·ç¨åå†è¯•ï¼Œå†·å´æ—¶é—´æœªç»“æŸ');
                        return;
                    }
                    
                    socket.emit('request_host');
                    requestHostCooldown.value = true;
                    
                    setTimeout(() => {
                        requestHostCooldown.value = false;
                    }, 8000);
                };

                const selectPuzzle = (id) => {
                    socket.emit('select_puzzle', id);
                };
                
                const submitCustomPuzzle = () => {
                    if (!customForm.value.title) {
                        alert('è¯·å¡«å†™æ ‡é¢˜');
                        return;
                    }
                    
                    // éªŒè¯æ±¤é¢ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasContentText = customForm.value.content && customForm.value.content.trim();
                    const hasContentImages = customForm.value.contentImages && customForm.value.contentImages.length > 0;
                    if (!hasContentText && !hasContentImages) {
                        alert('æ±¤é¢å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    // éªŒè¯æ±¤åº•ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasAnswerText = customForm.value.answer && customForm.value.answer.trim();
                    const hasAnswerImages = customForm.value.answerImages && customForm.value.answerImages.length > 0;
                    if (!hasAnswerText && !hasAnswerImages) {
                        alert('æ±¤åº•å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    if (!confirm('ç¡®å®šè¦ä½¿ç”¨è¿™ä¸ªè‡ªå®šä¹‰é¢˜ç›®å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                        return;
                    }

                    // æ·±æ‹·è´ä»¥é˜²æ­¢å¼•ç”¨é—®é¢˜
                    const payload = JSON.parse(JSON.stringify(customForm.value));
                    // æ·»åŠ é™åˆ¶è®¾ç½®
                    payload.maxQuestionsPerPlayer = settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null;
                    payload.maxTotalQuestions = settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null;
                    
                    socket.emit('create_custom_puzzle', payload);
                    
                    showCustomModal.value = false;
                    customForm.value = { title: '', content: '', answer: '', contentImages: [], answerImages: [] };
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                };

                const sendQuestion = () => {
                    if (!questionText.value.trim()) return;
                    socket.emit('ask_question', questionText.value);
                    questionText.value = '';
                    nextTick(() => {
                        const mobileInput = document.getElementById('mobile-question-input');
                        if (mobileInput) mobileInput.style.height = 'auto';
                    });
                };

                const answer = (questionId, type) => {
                    const customText = customAnswers.value[questionId];
                    socket.emit('answer_question', { 
                        questionId, 
                        answerType: type, 
                        customText 
                    });
                    // æ¸…ç†è¾“å…¥æ¡†
                    if (type === 'custom') delete customAnswers.value[questionId];
                };

                const revealAnswer = () => {
                    if(confirm('ç¡®å®šè¦æ­æ™“æ±¤åº•å¹¶ç»“æŸæœ¬å±€å—ï¼Ÿ')) {
                        socket.emit('reveal_answer');
                    }
                };

                const returnToLobby = () => {
                    if(confirm('ç¡®å®šè¦è¿”å›å¤§å…é€‰æ–°é¢˜å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                        socket.emit('return_to_lobby');
                    }
                };

                const scrollToBottom = () => {
                    nextTick(() => {
                        if (historyBox.value) {
                            historyBox.value.scrollTop = historyBox.value.scrollHeight;
                        }
                    });
                };

                // Socket Listeners
                onMounted(() => {
                    // è‡ªåŠ¨ç™»å½•æ£€æŸ¥
                    const storedNickname = localStorage.getItem('turtle_nickname');
                    const storedUserId = localStorage.getItem('turtle_uid');
                    
                    if (storedNickname) {
                        nickname.value = storedNickname;
                    }

                    if (storedNickname && storedUserId) {
                        joinGame();
                    }
                    
                    // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });

                const claimHost = () => {
                    socket.emit('claim_host');
                };

                const resignHost = () => {
                    if (confirm('ç¡®å®šè¦é€€å‡ºä¸»æŒäººè§’è‰²å—ï¼Ÿ')) {
                        socket.emit('resign_host');
                    }
                };

                const previewPuzzleDetails = (puzzle) => {
                    previewPuzzle.value = puzzle;
                    showPreviewModal.value = true;
                    // é‡ç½®è®¾ç½®è¡¨å•
                    settingsForm.value = { maxQuestionsPerPlayer: '', maxTotalQuestions: '' };
                };

                const confirmStartPuzzle = () => {
                    if (!previewPuzzle.value) return;
                    
                    const onlinePlayers = players.value.filter(p => p.isOnline);
                    if (onlinePlayers.length < 2) {
                        alert('è‡³å°‘éœ€è¦2åç©å®¶æ‰èƒ½å¼€å§‹æ¸¸æˆï¼ˆåŒ…æ‹¬ä¸»æŒäººï¼‰');
                        return;
                    }

                    const options = {
                        id: previewPuzzle.value.id,
                        maxQuestionsPerPlayer: settingsForm.value.maxQuestionsPerPlayer ? parseInt(settingsForm.value.maxQuestionsPerPlayer) : null,
                        maxTotalQuestions: settingsForm.value.maxTotalQuestions ? parseInt(settingsForm.value.maxTotalQuestions) : null
                    };

                    socket.emit('select_puzzle', options);
                    showPreviewModal.value = false;
                    previewPuzzle.value = null;
                };

                const recoverGame = () => {
                    socket.emit('recover_game');
                    showRecoveryDecision.value = false;
                };

                const startNewGame = () => {
                    if (confirm('ç¡®å®šè¦æ”¾å¼ƒä¸Šä¸€å±€æ¸¸æˆï¼Œå¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿ')) {
                        socket.emit('start_new_game');
                        showRecoveryDecision.value = false;
                    }
                };

                const kickPlayer = (playerId) => {
                    if (confirm('ç¡®å®šè¦è¸¢å‡ºè¯¥ç¦»çº¿ç©å®¶å—ï¼Ÿ')) {
                        socket.emit('kick_player', playerId);
                    }
                };
                
                const openEditModal = () => {
                    if (!currentPuzzle.value) return;
                    // å¡«å……å½“å‰é¢˜ç›®æ•°æ®
                    editForm.value = {
                        title: currentPuzzle.value.title || '',
                        content: currentPuzzle.value.content || '',
                        answer: currentPuzzle.value.answer || '',
                        contentImages: currentPuzzle.value.contentImages ? [...currentPuzzle.value.contentImages] : [],
                        answerImages: currentPuzzle.value.answerImages ? [...currentPuzzle.value.answerImages] : [],
                        maxQuestionsPerPlayer: gameLimits.value.maxQuestionsPerPlayer || '',
                        maxTotalQuestions: gameLimits.value.maxTotalQuestions || ''
                    };
                    showEditModal.value = true;
                };
                
                const submitEditPuzzle = () => {
                    if (!editForm.value.title) {
                        alert('è¯·å¡«å†™æ ‡é¢˜');
                        return;
                    }
                    
                    // éªŒè¯æ±¤é¢ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasContentText = editForm.value.content && editForm.value.content.trim();
                    const hasContentImages = editForm.value.contentImages && editForm.value.contentImages.length > 0;
                    if (!hasContentText && !hasContentImages) {
                        alert('æ±¤é¢å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    // éªŒè¯æ±¤åº•ï¼šæ–‡å­—æˆ–å›¾ç‰‡è‡³å°‘æœ‰ä¸€ä¸ª
                    const hasAnswerText = editForm.value.answer && editForm.value.answer.trim();
                    const hasAnswerImages = editForm.value.answerImages && editForm.value.answerImages.length > 0;
                    if (!hasAnswerText && !hasAnswerImages) {
                        alert('æ±¤åº•å¿…é¡»æä¾›æ–‡å­—æˆ–å›¾ç‰‡ï¼ˆè‡³å°‘ä¸€ç§ï¼‰');
                        return;
                    }
                    
                    if (!confirm('ç¡®å®šè¦ä¿å­˜ä¿®æ”¹å—ï¼Ÿ')) {
                        return;
                    }

                    const payload = JSON.parse(JSON.stringify(editForm.value));
                    payload.maxQuestionsPerPlayer = editForm.value.maxQuestionsPerPlayer ? parseInt(editForm.value.maxQuestionsPerPlayer) : null;
                    payload.maxTotalQuestions = editForm.value.maxTotalQuestions ? parseInt(editForm.value.maxTotalQuestions) : null;
                    
                    socket.emit('update_puzzle', payload);
                    
                    showEditModal.value = false;
                };

                const handleContentImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!customForm.value.contentImages) {
                                customForm.value.contentImages = [];
                            }
                            customForm.value.contentImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const handleAnswerImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!customForm.value.answerImages) {
                                customForm.value.answerImages = [];
                            }
                            customForm.value.answerImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const removeContentImage = (index) => {
                    customForm.value.contentImages.splice(index, 1);
                };
                
                const removeAnswerImage = (index) => {
                    customForm.value.answerImages.splice(index, 1);
                };
                
                const handleEditContentImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!editForm.value.contentImages) {
                                editForm.value.contentImages = [];
                            }
                            editForm.value.contentImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const handleEditAnswerImageUpload = (event) => {
                    const files = event.target.files;
                    if (!files || files.length === 0) return;
                    
                    const maxSize = 3 * 1024 * 1024; // 3MB
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.startsWith('image/')) {
                            alert(`æ–‡ä»¶ "${file.name}" ä¸æ˜¯å›¾ç‰‡æ ¼å¼`);
                            return;
                        }
                        
                        if (file.size > maxSize) {
                            alert(`å›¾ç‰‡ "${file.name}" è¶…è¿‡3MBé™åˆ¶ (å½“å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (!editForm.value.answerImages) {
                                editForm.value.answerImages = [];
                            }
                            editForm.value.answerImages.push(e.target.result);
                        };
                        reader.readAsDataURL(file);
                    });
                    event.target.value = '';
                };
                
                const removeEditContentImage = (index) => {
                    editForm.value.contentImages.splice(index, 1);
                };
                
                const removeEditAnswerImage = (index) => {
                    editForm.value.answerImages.splice(index, 1);
                };
                
                const openImageModal = (src, imageList = [], index = 0) => {
                    currentImageSrc.value = src;
                    currentImageList.value = imageList.length > 0 ? imageList : [src];
                    currentImageIndex.value = imageList.length > 0 ? index : 0;
                    showImageModal.value = true;
                };
                
                const closeImageModal = () => {
                    showImageModal.value = false;
                    currentImageSrc.value = '';
                    currentImageList.value = [];
                    currentImageIndex.value = 0;
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                const prevImage = () => {
                    if (currentImageList.value.length <= 1) return;
                    currentImageIndex.value = (currentImageIndex.value - 1 + currentImageList.value.length) % currentImageList.value.length;
                    currentImageSrc.value = currentImageList.value[currentImageIndex.value];
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                const nextImage = () => {
                    if (currentImageList.value.length <= 1) return;
                    currentImageIndex.value = (currentImageIndex.value + 1) % currentImageList.value.length;
                    currentImageSrc.value = currentImageList.value[currentImageIndex.value];
                    imageScale.value = 1;
                    imageTranslate.value = { x: 0, y: 0 };
                };
                
                // å›¾ç‰‡ç¼©æ”¾å’Œæ‹–åŠ¨åŠŸèƒ½
                const handleDoubleClick = (e) => {
                    e.stopPropagation();
                    if (imageScale.value === 1) {
                        imageScale.value = 2;
                    } else {
                        imageScale.value = 1;
                        imageTranslate.value = { x: 0, y: 0 };
                    }
                };
                
                const handleImageClick = (e) => {
                    if (imageScale.value === 1 && !e.target.closest('img')) {
                        closeImageModal();
                    }
                };
                
                const handleWheel = (e) => {
                    if (!showImageModal.value) return;
                    e.preventDefault();
                    
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    let newScale = imageScale.value + delta;
                    newScale = Math.max(1, Math.min(3, newScale)); // é™åˆ¶100%-300%
                    
                    if (newScale === 1) {
                        imageTranslate.value = { x: 0, y: 0 };
                    }
                    imageScale.value = newScale;
                };
                
                // é¼ æ ‡æ‹–åŠ¨
                let isDragging = false;
                let dragStart = { x: 0, y: 0 };
                let translateStart = { x: 0, y: 0 };
                
                const handleMouseDown = (e) => {
                    if (imageScale.value <= 1) return;
                    isDragging = true;
                    dragStart = { x: e.clientX, y: e.clientY };
                    translateStart = { ...imageTranslate.value };
                    e.preventDefault();
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging || imageScale.value <= 1) return;
                    const deltaX = (e.clientX - dragStart.x) / imageScale.value;
                    const deltaY = (e.clientY - dragStart.y) / imageScale.value;
                    imageTranslate.value = {
                        x: translateStart.x + deltaX,
                        y: translateStart.y + deltaY
                    };
                };
                
                const handleMouseUp = () => {
                    isDragging = false;
                };
                
                // è§¦æ‘¸ç¼©æ”¾
                let touchStart = null;
                let initialDistance = 0;
                let initialScale = 1;
                let touchStartTranslate = { x: 0, y: 0 };
                let lastTouchTime = 0;
                
                const handleTouchStart = (e) => {
                    if (e.touches.length === 2) {
                        // åŒæŒ‡ç¼©æ”¾
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        initialScale = imageScale.value;
                        e.preventDefault();
                    } else if (e.touches.length === 1) {
                        // å•æŒ‡æ‹–åŠ¨æˆ–åŒå‡»
                        const now = Date.now();
                        if (now - lastTouchTime < 300) {
                            // åŒå‡»
                            handleDoubleClick(e);
                        }
                        lastTouchTime = now;
                        
                        if (imageScale.value > 1) {
                            touchStart = {
                                x: e.touches[0].clientX,
                                y: e.touches[0].clientY
                            };
                            touchStartTranslate = { ...imageTranslate.value };
                        }
                    }
                };
                
                const handleTouchMove = (e) => {
                    if (e.touches.length === 2) {
                        // åŒæŒ‡ç¼©æ”¾
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const distance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        let newScale = initialScale * (distance / initialDistance);
                        newScale = Math.max(1, Math.min(3, newScale)); // é™åˆ¶100%-300%
                        
                        if (newScale === 1) {
                            imageTranslate.value = { x: 0, y: 0 };
                        }
                        imageScale.value = newScale;
                        e.preventDefault();
                    } else if (e.touches.length === 1 && touchStart && imageScale.value > 1) {
                        // å•æŒ‡æ‹–åŠ¨
                        const deltaX = (e.touches[0].clientX - touchStart.x) / imageScale.value;
                        const deltaY = (e.touches[0].clientY - touchStart.y) / imageScale.value;
                        imageTranslate.value = {
                            x: touchStartTranslate.x + deltaX,
                            y: touchStartTranslate.y + deltaY
                        };
                        e.preventDefault();
                    }
                };
                
                const handleTouchEnd = () => {
                    touchStart = null;
                };

                return {
                    joined, nickname, myId, isHost, players, puzzleList, 
                    currentPuzzle, history, questionText, customAnswers, gameOver,
                    joinGame, requestHost, selectPuzzle, sendQuestion, answer, revealAnswer, returnToLobby,
                    historyBox, showCustomModal, customForm, submitCustomPuzzle, hasHost, claimHost, resignHost,
                    showPreviewModal, previewPuzzle, previewPuzzleDetails, confirmStartPuzzle, requestHostCooldown,
                    serverConnected, showRecoveryDecision, showRecoveryWaiting, recoverGame, startNewGame,
                    isPuzzleExpanded, isAnswerExpanded, autoResize, gameLimits, settingsForm, myQuestionCount, publicUsedCount, canAskQuestion, questionPlaceholder,
                    kickPlayer, gameDuration, remainingTotal, shouldHighlightRemaining,
                    handleContentImageUpload, handleAnswerImageUpload, removeContentImage, removeAnswerImage,
                    showEditModal, editForm, openEditModal, submitEditPuzzle,
                    handleEditContentImageUpload, handleEditAnswerImageUpload, removeEditContentImage, removeEditAnswerImage,
                    showImageModal, currentImageSrc, currentImageList, currentImageIndex, openImageModal, closeImageModal, prevImage, nextImage,
                    zoomableImage, imageScale, imageTranslate,
                    handleDoubleClick, handleImageClick, handleWheel, handleMouseDown, handleTouchStart, handleTouchMove, handleTouchEnd
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
